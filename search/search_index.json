{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ritma Documentation Ritma is a court-grade forensic security observability platform. Start here Architecture Production setup CLI reference Specifications Forensics standard RTSL specification EEC specification","title":"Home"},{"location":"#ritma-documentation","text":"Ritma is a court-grade forensic security observability platform.","title":"Ritma Documentation"},{"location":"#start-here","text":"Architecture Production setup CLI reference","title":"Start here"},{"location":"#specifications","text":"Forensics standard RTSL specification EEC specification","title":"Specifications"},{"location":"ARCHITECTURE/","text":"","title":"Architecture"},{"location":"CLI_REFERENCE/","text":"Ritma CLI Reference Truthful-by-default. This reference covers the current ritma CLI exposed by the repository. Conventions Binary-first: examples use ritma ... (matches apt install ritma and target/release/ritma ). Dev mode: if you\u2019re developing, replace ritma with cargo run -p ritma_cli -- . Global flag: --json prints machine-readable output for supported commands. Paths are relative to current working directory unless otherwise noted. Commands Global help ritma --help ritma <command> --help demo-enhanced Run the enhanced demo showcasing all 8 security phases. ritma demo-enhanced attest Generate a canonical attestation JSON for a repository/folder and print the receipt hash. ritma attest --path . --namespace ns://demo/dev/hello/world Flags: - --path <dir> : folder to attest (default \".\") - --namespace <id> : namespace identifier - --out <dir> : optional output directory (defaults to ./ritma-attest-out/ ) Output: - Console: output path + sha256 - Files: attestation.json (canonical), attestation.sha256 bar-run-observe-only Read JSON events from stdin, evaluate with a no-op agent, and print decisions. echo '{\"namespace_id\":\"default\",\"kind\":\"event\",\"bar_decision\":\"deny\"}' | \\ ritma bar-run-observe-only bar-health Check connectivity to the BAR daemon and perform a simple round-trip test. ritma bar-health --help export Export artifacts from local evidence/index data. ritma export --help Subcommands: export report : auditor-readable report (when index DB is available) export window : export a forensic proofpack v2 for a window (by time range) export incident / export bundle / export proof : additional export flows (see --help ) Example (report): ritma export report --help export-proof Export a deterministic ProofPack (v0.1) for an ML window (when index DB is available). ritma export-proof --ml-id <id> --out ./out \\ --index-db /data/index_db.sqlite export-incident Build and (optionally) sign a compact incident manifest over a time range. ritma export-incident \\ --tenant acme --time-start 1700000000 --time-end 1700003600 \\ --framework SOC2 --out manifest.json Signing: - Uses node_keystore if RITMA_KEY_ID / RITMA_KEYSTORE_PATH are configured - Else uses env key UTLD_PACKAGE_SIG_KEY if present - Else computes an unsigned package hash verify-proof Verify an offline ProofPack folder. ritma verify-proof --path ./proofpack Notes: - If you have a .zip ProofPack, unzip it first and then pass the folder path. investigate Investigation workflows over commits/windows. ritma investigate --help diff Diff two ML windows and show attack-graph/feature deltas. ritma diff --a <old_ml_id> --b <new_ml_id> \\ --index-db /data/index_db.sqlite Shortcut for \"diff the last two windows\": ritma diff --last \\ --namespace ns://demo/dev/hello/world blame Find windows that introduced a needle (ip/proc/file). ritma blame --namespace ns://demo/dev/hello/world \\ --needle 1.2.3.4 --limit 10 --index-db /data/index_db.sqlite tag-add / tag-list Add and list tags for ML windows. ritma tag-add --namespace ns://demo/dev/hello/world \\ --name incident/123 --ml-id <id> ritma tag-list --namespace ns://demo/dev/hello/world commit-list / show-commit List or show ML window commits. ritma commit-list --namespace ns://demo/dev/hello/world --limit 5 ritma show-commit --ml-id <id> dna status / dna trace Runtime DNA is a per-namespace, hash-chained commit log derived from windows and evidence hashes. ritma dna status --namespace ns://demo/dev/hello/world ritma dna trace --namespace ns://demo/dev/hello/world --since 10 init / up (sidecar templates) Generate and bring up local sidecar manifests (docker or k8s modes), for future live wiring. ritma init --help ritma up --help deploy Generate deployment artifacts for common environments. ritma deploy --help Subcommands: deploy systemd deploy k8s deploy export deploy status doctor Basic diagnostics over index DB and namespace context (scaffolding). ritma doctor --index-db /data/index_db.sqlite --namespace ns://demo/dev/hello/world demo (legacy mini) Simulate a tiny incident and produce a simple proof. ritma demo --namespace ns://demo/dev/hello/world --window-secs 60 Tip: demo supports QR export and an embedded web server. Notes: - Some flows depend on other services or an index DB; commands will explain missing prerequisites.","title":"CLI Reference"},{"location":"CLI_REFERENCE/#ritma-cli-reference","text":"Truthful-by-default. This reference covers the current ritma CLI exposed by the repository.","title":"Ritma CLI Reference"},{"location":"CLI_REFERENCE/#conventions","text":"Binary-first: examples use ritma ... (matches apt install ritma and target/release/ritma ). Dev mode: if you\u2019re developing, replace ritma with cargo run -p ritma_cli -- . Global flag: --json prints machine-readable output for supported commands. Paths are relative to current working directory unless otherwise noted.","title":"Conventions"},{"location":"CLI_REFERENCE/#commands","text":"","title":"Commands"},{"location":"CLI_REFERENCE/#global-help","text":"ritma --help ritma <command> --help","title":"Global help"},{"location":"CLI_REFERENCE/#demo-enhanced","text":"Run the enhanced demo showcasing all 8 security phases. ritma demo-enhanced","title":"demo-enhanced"},{"location":"CLI_REFERENCE/#attest","text":"Generate a canonical attestation JSON for a repository/folder and print the receipt hash. ritma attest --path . --namespace ns://demo/dev/hello/world Flags: - --path <dir> : folder to attest (default \".\") - --namespace <id> : namespace identifier - --out <dir> : optional output directory (defaults to ./ritma-attest-out/ ) Output: - Console: output path + sha256 - Files: attestation.json (canonical), attestation.sha256","title":"attest"},{"location":"CLI_REFERENCE/#bar-run-observe-only","text":"Read JSON events from stdin, evaluate with a no-op agent, and print decisions. echo '{\"namespace_id\":\"default\",\"kind\":\"event\",\"bar_decision\":\"deny\"}' | \\ ritma bar-run-observe-only","title":"bar-run-observe-only"},{"location":"CLI_REFERENCE/#bar-health","text":"Check connectivity to the BAR daemon and perform a simple round-trip test. ritma bar-health --help","title":"bar-health"},{"location":"CLI_REFERENCE/#export","text":"Export artifacts from local evidence/index data. ritma export --help Subcommands: export report : auditor-readable report (when index DB is available) export window : export a forensic proofpack v2 for a window (by time range) export incident / export bundle / export proof : additional export flows (see --help ) Example (report): ritma export report --help","title":"export"},{"location":"CLI_REFERENCE/#export-proof","text":"Export a deterministic ProofPack (v0.1) for an ML window (when index DB is available). ritma export-proof --ml-id <id> --out ./out \\ --index-db /data/index_db.sqlite","title":"export-proof"},{"location":"CLI_REFERENCE/#export-incident","text":"Build and (optionally) sign a compact incident manifest over a time range. ritma export-incident \\ --tenant acme --time-start 1700000000 --time-end 1700003600 \\ --framework SOC2 --out manifest.json Signing: - Uses node_keystore if RITMA_KEY_ID / RITMA_KEYSTORE_PATH are configured - Else uses env key UTLD_PACKAGE_SIG_KEY if present - Else computes an unsigned package hash","title":"export-incident"},{"location":"CLI_REFERENCE/#verify-proof","text":"Verify an offline ProofPack folder. ritma verify-proof --path ./proofpack Notes: - If you have a .zip ProofPack, unzip it first and then pass the folder path.","title":"verify-proof"},{"location":"CLI_REFERENCE/#investigate","text":"Investigation workflows over commits/windows. ritma investigate --help","title":"investigate"},{"location":"CLI_REFERENCE/#diff","text":"Diff two ML windows and show attack-graph/feature deltas. ritma diff --a <old_ml_id> --b <new_ml_id> \\ --index-db /data/index_db.sqlite Shortcut for \"diff the last two windows\": ritma diff --last \\ --namespace ns://demo/dev/hello/world","title":"diff"},{"location":"CLI_REFERENCE/#blame","text":"Find windows that introduced a needle (ip/proc/file). ritma blame --namespace ns://demo/dev/hello/world \\ --needle 1.2.3.4 --limit 10 --index-db /data/index_db.sqlite","title":"blame"},{"location":"CLI_REFERENCE/#tag-add-tag-list","text":"Add and list tags for ML windows. ritma tag-add --namespace ns://demo/dev/hello/world \\ --name incident/123 --ml-id <id> ritma tag-list --namespace ns://demo/dev/hello/world","title":"tag-add / tag-list"},{"location":"CLI_REFERENCE/#commit-list-show-commit","text":"List or show ML window commits. ritma commit-list --namespace ns://demo/dev/hello/world --limit 5 ritma show-commit --ml-id <id>","title":"commit-list / show-commit"},{"location":"CLI_REFERENCE/#dna-status-dna-trace","text":"Runtime DNA is a per-namespace, hash-chained commit log derived from windows and evidence hashes. ritma dna status --namespace ns://demo/dev/hello/world ritma dna trace --namespace ns://demo/dev/hello/world --since 10","title":"dna status / dna trace"},{"location":"CLI_REFERENCE/#init-up-sidecar-templates","text":"Generate and bring up local sidecar manifests (docker or k8s modes), for future live wiring. ritma init --help ritma up --help","title":"init / up (sidecar templates)"},{"location":"CLI_REFERENCE/#deploy","text":"Generate deployment artifacts for common environments. ritma deploy --help Subcommands: deploy systemd deploy k8s deploy export deploy status","title":"deploy"},{"location":"CLI_REFERENCE/#doctor","text":"Basic diagnostics over index DB and namespace context (scaffolding). ritma doctor --index-db /data/index_db.sqlite --namespace ns://demo/dev/hello/world","title":"doctor"},{"location":"CLI_REFERENCE/#demo-legacy-mini","text":"Simulate a tiny incident and produce a simple proof. ritma demo --namespace ns://demo/dev/hello/world --window-secs 60 Tip: demo supports QR export and an embedded web server. Notes: - Some flows depend on other services or an index DB; commands will explain missing prerequisites.","title":"demo (legacy mini)"},{"location":"EEC_SPEC/","text":"Execution-Entropy Consensus (EEC) Specification Version: 0.1 Status: Draft Last Updated: 2026-01-19 Abstract Execution-Entropy Consensus (EEC) is a constraint-survival model for forensic audit logs. It ensures that recorded execution traces are admissible as evidence by enforcing five orthogonal constraints: temporal, causal, cryptographic, observational, and entropic. This document specifies the EEC model, maps constraints to Ritma ProofPack artifacts, and provides citations to foundational research. 1. Introduction Traditional audit logs suffer from: - Tampering : Logs can be modified after the fact. - Repudiation : Actors can deny actions. - Clock manipulation : Timestamps can be forged. - Selective omission : Events can be dropped without detection. EEC addresses these by requiring that every recorded artifact survives a set of verifiable constraints. If any constraint fails, the artifact is inadmissible. 1.1 Design Goals Offline verifiability : No network access required for verification. Hardware-backed trust : Optional TPM attestation for observational/entropic constraints. Incremental sealing : Proofs generated per micro-window (\u226460s) and aggregated hourly. Backward compatibility : Older bundles without signatures/TPM remain verifiable (with warnings). 2. The Five EEC Constraints 2.1 Temporal Constraint Definition : Events must be ordered by a monotonic, tamper-evident clock. Implementation : - Each micro-window has start_ts and end_ts (Unix epoch, nanoseconds). - Hour roots aggregate micro-windows in chronological order. - Chain records link hours with prev_root forming a hash chain. Verification : - OfflineVerifier::verify_chain() checks prev_root linkage. - Timestamps must be monotonically increasing within and across windows. Citations : - Haber, S., & Stornetta, W. S. (1991). \"How to Time-Stamp a Digital Document.\" Journal of Cryptology . - RFC 3161: Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP). 2.2 Causal Constraint Definition : Events must preserve causal ordering (happens-before relationships). Implementation : - Micro-window Merkle trees preserve leaf order. - Hour root is computed from ordered micro-roots. - Chain hash includes previous hour root, enforcing causal dependency. Verification : - OfflineVerifier::verify_hours() recomputes hour root from micro-roots. - merkle_root_sha256() preserves insertion order. Citations : - Lamport, L. (1978). \"Time, Clocks, and the Ordering of Events in a Distributed System.\" Communications of the ACM . 2.3 Cryptographic Constraint Definition : All artifacts must be cryptographically bound to their contents. Implementation : - Micro-window : micro_root = Merkle root of leaf hashes (SHA-256). - Hour root : hour_root = Merkle root of micro-roots. - Chain hash : chain_hash = SHA256(\"ritma-chain-hash@0.1\" || prev_root || hour_root) . - Signatures : Ed25519 signatures on micro, hour, and chain artifacts. Artifacts : | File | Tag | Signed Payload | |------|-----|----------------| | micro/*.sig | ritma-micro-sig@0.1 | micro_root | | proofs/hour_root.sig | ritma-hour-root-sig@0.1 | hour_root | | proofs/chain.sig | ritma-chain-sig@0.1 | chain_hash | Verification : - verify_sig_file() loads public keys from _meta/keys/pubkeys.cbor . - Signature format: (\"ritma-sig@0.1\", key_id, alg, payload_hex, sig_hex) . Citations : - Bernstein, D. J., et al. (2012). \"High-speed high-security signatures.\" Journal of Cryptographic Engineering . - RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA). 2.4 Observational Constraint Definition : The recording environment must be attested by a trusted observer. Implementation : - TPM 2.0 quote binds the chain hash to platform state (PCR values). - tpm_quote.cbor : Contains PCR selection, nonce (chain hash), signature, AIK public key. - tpm_binding.cbor : Links quote hash to chain hash with timestamp. Verification : - OfflineVerifier::verify_tpm_binding() checks: - Quote nonce matches chain hash. - PCR digest is consistent. - Signature verifies against AIK. Citations : - Trusted Computing Group. (2019). \"TPM 2.0 Library Specification.\" - Parno, B., et al. (2010). \"Bootstrapping Trust in Commodity Computers.\" IEEE S&P . 2.5 Entropic Constraint Definition : Artifacts must contain sufficient entropy to prevent pre-computation attacks. Implementation : - Leaf hashes include event-specific data (timestamps, PIDs, hashes of binaries). - TPM nonce is derived from chain hash (unpredictable without prior events). - Micro-window IDs include nanosecond timestamps. Verification : - Implicit: If cryptographic and observational constraints pass, entropic constraint is satisfied. - Future: Entropy estimation on leaf data distributions. Citations : - Dodis, Y., et al. (2004). \"On the (Im)possibility of Cryptography with Imperfect Randomness.\" FOCS . 3. Artifact Schema 3.1 Micro-Window ( ritma-micro@0.2 ) ( \"ritma-micro@0.2\", // tag window_id, // string: YYYYMMDD_HHMMSS_nnnnnnnnn node_id, // string start_ts, // i64: Unix epoch ns end_ts, // i64: Unix epoch ns event_count, // u64 leaf_count, // u64 micro_root_hex // string: 64 hex chars (SHA-256) ) 3.2 Micro Leaves Sidecar ( ritma-micro-leaves@0.1 ) ( \"ritma-micro-leaves@0.1\", // tag window_id, // string [leaf_hex, ...] // array of 64-char hex strings ) Stored as micro/{window_id}.leaves.cbor.zst (zstd compressed). 3.3 Hour Root ( ritma-hour-root@0.2 ) ( \"ritma-hour-root@0.2\", // tag node_id, // string hour_ts, // i64: Unix epoch (hour start) hour_root_hex, // string: 64 hex chars [micro_root_hex, ...] // array of micro roots in order ) 3.4 Chain Record ( ritma-chain@0.3 ) ( \"ritma-chain@0.3\", // tag node_id, // string hour_ts, // i64 prev_root_hex, // string: 64 hex chars (or GENESIS hash) hour_root_hex, // string: 64 hex chars chain_hash_hex // string: 64 hex chars ) 3.5 Signature File ( ritma-sig@0.1 ) ( \"ritma-sig@0.1\", // tag key_id, // string: key identifier alg, // string: \"ed25519\" or \"none\" payload_hex, // string: 64 hex chars (what was signed) sig_hex // string: 128 hex chars (Ed25519 signature) ) 3.6 Public Keys ( ritma-pubkeys@0.2 ) ( \"ritma-pubkeys@0.2\", // tag node_id, // string [ { \"key_id\": string, \"algorithm\": string, \"public_key_hash\": string, // SHA-256 of public key \"ed25519_pubkey\": string // 64 hex chars (32 bytes) }, ... ] ) 3.7 TPM Quote ( ritma-tpm-quote@0.1 ) { \"version\": \"ritma-tpm-quote@0.1\", \"pcr_selection\": { \"hash_alg\": \"sha256\", \"pcrs\": [0, 1, 2, ...] }, \"pcr_digest\": string, // hex \"nonce\": string, // hex (should match chain_hash) \"signature\": string, // hex \"aik_public\": string, // hex (AIK public key) \"is_hardware\": bool, \"timestamp\": i64 } 3.8 TPM Binding ( ritma-tpm-binding@0.1 ) { \"version\": \"ritma-tpm-binding@0.1\", \"quote_hash\": string, // SHA-256 of serialized quote \"pcr_digest\": string, \"is_hardware\": bool, \"timestamp\": i64, \"node_id\": string } 4. Verification Flow OfflineVerifier::verify_all() \u251c\u2500\u2500 load_pubkeys() // _meta/keys/pubkeys.cbor \u251c\u2500\u2500 verify_chain() // chain.cbor linkage \u2502 \u251c\u2500\u2500 for each hour: \u2502 \u2502 \u251c\u2500\u2500 verify_chain_record() // prev_root, chain_hash \u2502 \u2502 \u251c\u2500\u2500 verify_sig_file(chain.sig) \u2502 \u2502 \u2514\u2500\u2500 verify_tpm_binding() // optional \u251c\u2500\u2500 verify_hours() // hour_root.cbor \u2502 \u251c\u2500\u2500 for each hour: \u2502 \u2502 \u251c\u2500\u2500 verify_hour_root() // recompute from micro_roots \u2502 \u2502 \u251c\u2500\u2500 verify_sig_file(hour_root.sig) \u2502 \u2502 \u2514\u2500\u2500 verify_micro_windows() \u2502 \u2502 \u251c\u2500\u2500 for each micro: \u2502 \u2502 \u2502 \u251c\u2500\u2500 read_micro_root() \u2502 \u2502 \u2502 \u251c\u2500\u2500 read_micro_leaves() \u2502 \u2502 \u2502 \u251c\u2500\u2500 merkle_root_sha256(leaves) == claimed_root \u2502 \u2502 \u2502 \u2514\u2500\u2500 verify_sig_file(micro.sig) \u2514\u2500\u2500 aggregate stats and errors 5. Environment Variables Variable Default Description RITMA_OUT_REQUIRE_SIGNATURE false Fail sealing if signing unavailable RITMA_VERIFY_REQUIRE_SIGNATURE false Fail verification if signatures missing/invalid RITMA_OUT_REQUIRE_TPM false Fail sealing if TPM unavailable RITMA_VERIFY_REQUIRE_TPM false Fail verification if TPM binding missing/invalid RITMA_SIGNING_KEY_ID (auto) Key ID to use for signing 6. Code Mapping Constraint Sealing Code Verification Code Temporal StorageContract::write_micro_window_proof() OfflineVerifier::verify_chain() Causal compute_hour_root_from_micro() OfflineVerifier::verify_hours() Cryptographic write_sig_file() , merkle_root_sha256() verify_sig_file() , merkle_root_sha256() Observational TpmAttestor::attest() OfflineVerifier::verify_tpm_binding() Entropic canonical_leaf_hash() (implicit) Key Files : - crates/ritma_contract/src/lib.rs : Sealing pipeline, signature generation. - crates/ritma_contract/src/verify.rs : OfflineVerifier implementation. - crates/node_keystore/src/lib.rs : Key management, sign_bytes() . - crates/node_keystore/src/tpm.rs : TPM attestation. - crates/ritma_cli/src/main.rs : cmd_verify_proof() , cmd_verify_ritma_out_bundle() . 7. Security Considerations 7.1 Key Management Ed25519 private keys are stored in node_keystore with zeroization on drop. Public keys exported to _meta/keys/pubkeys.cbor for offline verification. Key rotation: New keys can be added; old signatures remain valid. 7.2 TPM Trust Hardware TPM provides strongest guarantees. Simulated TPM (swtpm) acceptable for development/testing only. is_hardware flag in binding distinguishes trust levels. 7.3 Replay Attacks Chain hash includes previous hour root, preventing insertion. TPM nonce is chain hash, binding quote to specific chain state. 7.4 Clock Attacks Monotonic timestamps enforced within node. Cross-node synchronization requires external trusted time (RFC 3161 TSR). 8. Future Work Witness cosigning : Multiple nodes sign the same chain hash (threshold signatures). Certificate Transparency integration : Publish chain hashes to CT logs. Entropy estimation : Statistical tests on leaf data distributions. Formal verification : Prove constraint satisfaction in Coq/Lean. References Haber, S., & Stornetta, W. S. (1991). \"How to Time-Stamp a Digital Document.\" Journal of Cryptology , 3(2), 99-111. Lamport, L. (1978). \"Time, Clocks, and the Ordering of Events in a Distributed System.\" Communications of the ACM , 21(7), 558-565. Bernstein, D. J., Duif, N., Lange, T., Schwabe, P., & Yang, B. Y. (2012). \"High-speed high-security signatures.\" Journal of Cryptographic Engineering , 2(2), 77-89. Trusted Computing Group. (2019). \"Trusted Platform Module Library Specification, Family 2.0.\" Parno, B., McCune, J. M., & Perrig, A. (2010). \"Bootstrapping Trust in Commodity Computers.\" IEEE Symposium on Security and Privacy . Dodis, Y., Reyzin, L., & Smith, A. (2004). \"On the (Im)possibility of Cryptography with Imperfect Randomness.\" FOCS . RFC 3161: Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP). RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA). Laurie, B., Langley, A., & Kasper, E. (2013). \"Certificate Transparency.\" RFC 6962. Appendix A: Example Verification Output $ ritma verify-proof /var/ritma_out/ns-demo RITMA_OUT bundle verify (path=/var/ritma_out/ns-demo) status: OK hours_verified: 24 micro_windows_verified: 1440 chain_links_verified: 24 signatures_verified: 2928 bytes_verified: 15728640 { \"bundle_type\": \"ritma_out\", \"path\": \"/var/ritma_out/ns-demo\", \"valid\": true, \"errors\": [], \"warnings\": [], \"stats\": { \"hours_verified\": 24, \"micro_windows_verified\": 1440, \"chain_links_verified\": 24, \"signatures_verified\": 2928, \"bytes_verified\": 15728640 } }","title":"EEC Spec"},{"location":"EEC_SPEC/#execution-entropy-consensus-eec-specification","text":"Version: 0.1 Status: Draft Last Updated: 2026-01-19","title":"Execution-Entropy Consensus (EEC) Specification"},{"location":"EEC_SPEC/#abstract","text":"Execution-Entropy Consensus (EEC) is a constraint-survival model for forensic audit logs. It ensures that recorded execution traces are admissible as evidence by enforcing five orthogonal constraints: temporal, causal, cryptographic, observational, and entropic. This document specifies the EEC model, maps constraints to Ritma ProofPack artifacts, and provides citations to foundational research.","title":"Abstract"},{"location":"EEC_SPEC/#1-introduction","text":"Traditional audit logs suffer from: - Tampering : Logs can be modified after the fact. - Repudiation : Actors can deny actions. - Clock manipulation : Timestamps can be forged. - Selective omission : Events can be dropped without detection. EEC addresses these by requiring that every recorded artifact survives a set of verifiable constraints. If any constraint fails, the artifact is inadmissible.","title":"1. Introduction"},{"location":"EEC_SPEC/#11-design-goals","text":"Offline verifiability : No network access required for verification. Hardware-backed trust : Optional TPM attestation for observational/entropic constraints. Incremental sealing : Proofs generated per micro-window (\u226460s) and aggregated hourly. Backward compatibility : Older bundles without signatures/TPM remain verifiable (with warnings).","title":"1.1 Design Goals"},{"location":"EEC_SPEC/#2-the-five-eec-constraints","text":"","title":"2. The Five EEC Constraints"},{"location":"EEC_SPEC/#21-temporal-constraint","text":"Definition : Events must be ordered by a monotonic, tamper-evident clock. Implementation : - Each micro-window has start_ts and end_ts (Unix epoch, nanoseconds). - Hour roots aggregate micro-windows in chronological order. - Chain records link hours with prev_root forming a hash chain. Verification : - OfflineVerifier::verify_chain() checks prev_root linkage. - Timestamps must be monotonically increasing within and across windows. Citations : - Haber, S., & Stornetta, W. S. (1991). \"How to Time-Stamp a Digital Document.\" Journal of Cryptology . - RFC 3161: Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP).","title":"2.1 Temporal Constraint"},{"location":"EEC_SPEC/#22-causal-constraint","text":"Definition : Events must preserve causal ordering (happens-before relationships). Implementation : - Micro-window Merkle trees preserve leaf order. - Hour root is computed from ordered micro-roots. - Chain hash includes previous hour root, enforcing causal dependency. Verification : - OfflineVerifier::verify_hours() recomputes hour root from micro-roots. - merkle_root_sha256() preserves insertion order. Citations : - Lamport, L. (1978). \"Time, Clocks, and the Ordering of Events in a Distributed System.\" Communications of the ACM .","title":"2.2 Causal Constraint"},{"location":"EEC_SPEC/#23-cryptographic-constraint","text":"Definition : All artifacts must be cryptographically bound to their contents. Implementation : - Micro-window : micro_root = Merkle root of leaf hashes (SHA-256). - Hour root : hour_root = Merkle root of micro-roots. - Chain hash : chain_hash = SHA256(\"ritma-chain-hash@0.1\" || prev_root || hour_root) . - Signatures : Ed25519 signatures on micro, hour, and chain artifacts. Artifacts : | File | Tag | Signed Payload | |------|-----|----------------| | micro/*.sig | ritma-micro-sig@0.1 | micro_root | | proofs/hour_root.sig | ritma-hour-root-sig@0.1 | hour_root | | proofs/chain.sig | ritma-chain-sig@0.1 | chain_hash | Verification : - verify_sig_file() loads public keys from _meta/keys/pubkeys.cbor . - Signature format: (\"ritma-sig@0.1\", key_id, alg, payload_hex, sig_hex) . Citations : - Bernstein, D. J., et al. (2012). \"High-speed high-security signatures.\" Journal of Cryptographic Engineering . - RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA).","title":"2.3 Cryptographic Constraint"},{"location":"EEC_SPEC/#24-observational-constraint","text":"Definition : The recording environment must be attested by a trusted observer. Implementation : - TPM 2.0 quote binds the chain hash to platform state (PCR values). - tpm_quote.cbor : Contains PCR selection, nonce (chain hash), signature, AIK public key. - tpm_binding.cbor : Links quote hash to chain hash with timestamp. Verification : - OfflineVerifier::verify_tpm_binding() checks: - Quote nonce matches chain hash. - PCR digest is consistent. - Signature verifies against AIK. Citations : - Trusted Computing Group. (2019). \"TPM 2.0 Library Specification.\" - Parno, B., et al. (2010). \"Bootstrapping Trust in Commodity Computers.\" IEEE S&P .","title":"2.4 Observational Constraint"},{"location":"EEC_SPEC/#25-entropic-constraint","text":"Definition : Artifacts must contain sufficient entropy to prevent pre-computation attacks. Implementation : - Leaf hashes include event-specific data (timestamps, PIDs, hashes of binaries). - TPM nonce is derived from chain hash (unpredictable without prior events). - Micro-window IDs include nanosecond timestamps. Verification : - Implicit: If cryptographic and observational constraints pass, entropic constraint is satisfied. - Future: Entropy estimation on leaf data distributions. Citations : - Dodis, Y., et al. (2004). \"On the (Im)possibility of Cryptography with Imperfect Randomness.\" FOCS .","title":"2.5 Entropic Constraint"},{"location":"EEC_SPEC/#3-artifact-schema","text":"","title":"3. Artifact Schema"},{"location":"EEC_SPEC/#31-micro-window-ritma-micro02","text":"( \"ritma-micro@0.2\", // tag window_id, // string: YYYYMMDD_HHMMSS_nnnnnnnnn node_id, // string start_ts, // i64: Unix epoch ns end_ts, // i64: Unix epoch ns event_count, // u64 leaf_count, // u64 micro_root_hex // string: 64 hex chars (SHA-256) )","title":"3.1 Micro-Window (ritma-micro@0.2)"},{"location":"EEC_SPEC/#32-micro-leaves-sidecar-ritma-micro-leaves01","text":"( \"ritma-micro-leaves@0.1\", // tag window_id, // string [leaf_hex, ...] // array of 64-char hex strings ) Stored as micro/{window_id}.leaves.cbor.zst (zstd compressed).","title":"3.2 Micro Leaves Sidecar (ritma-micro-leaves@0.1)"},{"location":"EEC_SPEC/#33-hour-root-ritma-hour-root02","text":"( \"ritma-hour-root@0.2\", // tag node_id, // string hour_ts, // i64: Unix epoch (hour start) hour_root_hex, // string: 64 hex chars [micro_root_hex, ...] // array of micro roots in order )","title":"3.3 Hour Root (ritma-hour-root@0.2)"},{"location":"EEC_SPEC/#34-chain-record-ritma-chain03","text":"( \"ritma-chain@0.3\", // tag node_id, // string hour_ts, // i64 prev_root_hex, // string: 64 hex chars (or GENESIS hash) hour_root_hex, // string: 64 hex chars chain_hash_hex // string: 64 hex chars )","title":"3.4 Chain Record (ritma-chain@0.3)"},{"location":"EEC_SPEC/#35-signature-file-ritma-sig01","text":"( \"ritma-sig@0.1\", // tag key_id, // string: key identifier alg, // string: \"ed25519\" or \"none\" payload_hex, // string: 64 hex chars (what was signed) sig_hex // string: 128 hex chars (Ed25519 signature) )","title":"3.5 Signature File (ritma-sig@0.1)"},{"location":"EEC_SPEC/#36-public-keys-ritma-pubkeys02","text":"( \"ritma-pubkeys@0.2\", // tag node_id, // string [ { \"key_id\": string, \"algorithm\": string, \"public_key_hash\": string, // SHA-256 of public key \"ed25519_pubkey\": string // 64 hex chars (32 bytes) }, ... ] )","title":"3.6 Public Keys (ritma-pubkeys@0.2)"},{"location":"EEC_SPEC/#37-tpm-quote-ritma-tpm-quote01","text":"{ \"version\": \"ritma-tpm-quote@0.1\", \"pcr_selection\": { \"hash_alg\": \"sha256\", \"pcrs\": [0, 1, 2, ...] }, \"pcr_digest\": string, // hex \"nonce\": string, // hex (should match chain_hash) \"signature\": string, // hex \"aik_public\": string, // hex (AIK public key) \"is_hardware\": bool, \"timestamp\": i64 }","title":"3.7 TPM Quote (ritma-tpm-quote@0.1)"},{"location":"EEC_SPEC/#38-tpm-binding-ritma-tpm-binding01","text":"{ \"version\": \"ritma-tpm-binding@0.1\", \"quote_hash\": string, // SHA-256 of serialized quote \"pcr_digest\": string, \"is_hardware\": bool, \"timestamp\": i64, \"node_id\": string }","title":"3.8 TPM Binding (ritma-tpm-binding@0.1)"},{"location":"EEC_SPEC/#4-verification-flow","text":"OfflineVerifier::verify_all() \u251c\u2500\u2500 load_pubkeys() // _meta/keys/pubkeys.cbor \u251c\u2500\u2500 verify_chain() // chain.cbor linkage \u2502 \u251c\u2500\u2500 for each hour: \u2502 \u2502 \u251c\u2500\u2500 verify_chain_record() // prev_root, chain_hash \u2502 \u2502 \u251c\u2500\u2500 verify_sig_file(chain.sig) \u2502 \u2502 \u2514\u2500\u2500 verify_tpm_binding() // optional \u251c\u2500\u2500 verify_hours() // hour_root.cbor \u2502 \u251c\u2500\u2500 for each hour: \u2502 \u2502 \u251c\u2500\u2500 verify_hour_root() // recompute from micro_roots \u2502 \u2502 \u251c\u2500\u2500 verify_sig_file(hour_root.sig) \u2502 \u2502 \u2514\u2500\u2500 verify_micro_windows() \u2502 \u2502 \u251c\u2500\u2500 for each micro: \u2502 \u2502 \u2502 \u251c\u2500\u2500 read_micro_root() \u2502 \u2502 \u2502 \u251c\u2500\u2500 read_micro_leaves() \u2502 \u2502 \u2502 \u251c\u2500\u2500 merkle_root_sha256(leaves) == claimed_root \u2502 \u2502 \u2502 \u2514\u2500\u2500 verify_sig_file(micro.sig) \u2514\u2500\u2500 aggregate stats and errors","title":"4. Verification Flow"},{"location":"EEC_SPEC/#5-environment-variables","text":"Variable Default Description RITMA_OUT_REQUIRE_SIGNATURE false Fail sealing if signing unavailable RITMA_VERIFY_REQUIRE_SIGNATURE false Fail verification if signatures missing/invalid RITMA_OUT_REQUIRE_TPM false Fail sealing if TPM unavailable RITMA_VERIFY_REQUIRE_TPM false Fail verification if TPM binding missing/invalid RITMA_SIGNING_KEY_ID (auto) Key ID to use for signing","title":"5. Environment Variables"},{"location":"EEC_SPEC/#6-code-mapping","text":"Constraint Sealing Code Verification Code Temporal StorageContract::write_micro_window_proof() OfflineVerifier::verify_chain() Causal compute_hour_root_from_micro() OfflineVerifier::verify_hours() Cryptographic write_sig_file() , merkle_root_sha256() verify_sig_file() , merkle_root_sha256() Observational TpmAttestor::attest() OfflineVerifier::verify_tpm_binding() Entropic canonical_leaf_hash() (implicit) Key Files : - crates/ritma_contract/src/lib.rs : Sealing pipeline, signature generation. - crates/ritma_contract/src/verify.rs : OfflineVerifier implementation. - crates/node_keystore/src/lib.rs : Key management, sign_bytes() . - crates/node_keystore/src/tpm.rs : TPM attestation. - crates/ritma_cli/src/main.rs : cmd_verify_proof() , cmd_verify_ritma_out_bundle() .","title":"6. Code Mapping"},{"location":"EEC_SPEC/#7-security-considerations","text":"","title":"7. Security Considerations"},{"location":"EEC_SPEC/#71-key-management","text":"Ed25519 private keys are stored in node_keystore with zeroization on drop. Public keys exported to _meta/keys/pubkeys.cbor for offline verification. Key rotation: New keys can be added; old signatures remain valid.","title":"7.1 Key Management"},{"location":"EEC_SPEC/#72-tpm-trust","text":"Hardware TPM provides strongest guarantees. Simulated TPM (swtpm) acceptable for development/testing only. is_hardware flag in binding distinguishes trust levels.","title":"7.2 TPM Trust"},{"location":"EEC_SPEC/#73-replay-attacks","text":"Chain hash includes previous hour root, preventing insertion. TPM nonce is chain hash, binding quote to specific chain state.","title":"7.3 Replay Attacks"},{"location":"EEC_SPEC/#74-clock-attacks","text":"Monotonic timestamps enforced within node. Cross-node synchronization requires external trusted time (RFC 3161 TSR).","title":"7.4 Clock Attacks"},{"location":"EEC_SPEC/#8-future-work","text":"Witness cosigning : Multiple nodes sign the same chain hash (threshold signatures). Certificate Transparency integration : Publish chain hashes to CT logs. Entropy estimation : Statistical tests on leaf data distributions. Formal verification : Prove constraint satisfaction in Coq/Lean.","title":"8. Future Work"},{"location":"EEC_SPEC/#references","text":"Haber, S., & Stornetta, W. S. (1991). \"How to Time-Stamp a Digital Document.\" Journal of Cryptology , 3(2), 99-111. Lamport, L. (1978). \"Time, Clocks, and the Ordering of Events in a Distributed System.\" Communications of the ACM , 21(7), 558-565. Bernstein, D. J., Duif, N., Lange, T., Schwabe, P., & Yang, B. Y. (2012). \"High-speed high-security signatures.\" Journal of Cryptographic Engineering , 2(2), 77-89. Trusted Computing Group. (2019). \"Trusted Platform Module Library Specification, Family 2.0.\" Parno, B., McCune, J. M., & Perrig, A. (2010). \"Bootstrapping Trust in Commodity Computers.\" IEEE Symposium on Security and Privacy . Dodis, Y., Reyzin, L., & Smith, A. (2004). \"On the (Im)possibility of Cryptography with Imperfect Randomness.\" FOCS . RFC 3161: Internet X.509 Public Key Infrastructure Time-Stamp Protocol (TSP). RFC 8032: Edwards-Curve Digital Signature Algorithm (EdDSA). Laurie, B., Langley, A., & Kasper, E. (2013). \"Certificate Transparency.\" RFC 6962.","title":"References"},{"location":"EEC_SPEC/#appendix-a-example-verification-output","text":"$ ritma verify-proof /var/ritma_out/ns-demo RITMA_OUT bundle verify (path=/var/ritma_out/ns-demo) status: OK hours_verified: 24 micro_windows_verified: 1440 chain_links_verified: 24 signatures_verified: 2928 bytes_verified: 15728640 { \"bundle_type\": \"ritma_out\", \"path\": \"/var/ritma_out/ns-demo\", \"valid\": true, \"errors\": [], \"warnings\": [], \"stats\": { \"hours_verified\": 24, \"micro_windows_verified\": 1440, \"chain_links_verified\": 24, \"signatures_verified\": 2928, \"bytes_verified\": 15728640 } }","title":"Appendix A: Example Verification Output"},{"location":"RTSL_SPEC/","text":"Ritma Transparent Segment Ledger (RTSL) Specification Version: 1.0 Status: Draft Date: 2026-01-19 Abstract RTSL (Ritma Transparent Segment Ledger) is a production-grade output format for forensic audit logs that combines: WARC-style append-only segments for stability and reduced filesystem operations Certificate Transparency (CT) Merkle proofs for cryptographic append-only guarantees Sigstore/Rekor sharding for infinite scalability IPLD CAR content-addressing for deduplication and efficient exports Git packfile delta compression for storage efficiency Merkle Mountain Range (MMR) for efficient append-only proofs This format replaces the current \"folder dump\" approach with a court-ready, production-stable, easily traceable archive system. Table of Contents Design Goals Directory Structure Segment Files (.rseg) Index Files (.ridx) Root Files (.rroot) Merkle Structure Sharding Strategy Content-Addressed Blocks Locator System Verification Protocol Compression Cold Storage & Retention Court Admissibility Migration from v1 References 1. Design Goals 1.1 Stability (Production-Critical) Problem (Current) Solution (RTSL) Source Millions of small files Append-only segment files WARC ISO 28500 [1] Filesystem exhaustion Few large files per hour WARC best practices Crash corruption Atomic segment finalization WAL pattern [2] Index corruption Rebuildable from segments Git packfile design [3] 1.2 Traceability (Court-Ready) Requirement RTSL Feature Source Precise event location LOC = (shard, segment, offset, len) WARC record offsets Tamper detection Merkle inclusion proofs RFC 6962/9162 [4][5] Append-only guarantee Signed Tree Heads (STH) Certificate Transparency Chain of custody Custody records in segments NIST IR 8387 [6] 1.3 Scalability (Enterprise-Grade) Challenge Solution Source Unbounded growth Time-based sharding Sigstore/Rekor [7] Verification cost MMR for O(log n) proofs Grin MMR [8] Storage cost Delta compression + dedup Git packfiles [3] Export size Content-addressed blocks IPLD CAR [9] 2. Directory Structure ledger/ \u251c\u2500\u2500 v2/ # Format version \u2502 \u251c\u2500\u2500 CURRENT # Active shard pointer \u2502 \u251c\u2500\u2500 shards/ \u2502 \u2502 \u2514\u2500\u2500 2026/ \u2502 \u2502 \u2514\u2500\u2500 01/ \u2502 \u2502 \u2514\u2500\u2500 19/ \u2502 \u2502 \u2514\u2500\u2500 10/ # Hour shard (YYYYMMDDHH) \u2502 \u2502 \u251c\u2500\u2500 segments/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 00.rseg # Minute 00-09 \u2502 \u2502 \u2502 \u251c\u2500\u2500 10.rseg # Minute 10-19 \u2502 \u2502 \u2502 \u251c\u2500\u2500 20.rseg # ... \u2502 \u2502 \u2502 \u251c\u2500\u2500 30.rseg \u2502 \u2502 \u2502 \u251c\u2500\u2500 40.rseg \u2502 \u2502 \u2502 \u2514\u2500\u2500 50.rseg \u2502 \u2502 \u251c\u2500\u2500 index/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 time.ridx # Time \u2192 offset index \u2502 \u2502 \u2502 \u251c\u2500\u2500 object.ridx # ObjectID \u2192 offsets \u2502 \u2502 \u2502 \u2514\u2500\u2500 hash.ridx # ContentHash \u2192 offset \u2502 \u2502 \u251c\u2500\u2500 roots/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 hour.rroot # Signed hour root \u2502 \u2502 \u2502 \u2514\u2500\u2500 hour.rroot.sig \u2502 \u2502 \u2514\u2500\u2500 blocks/ \u2502 \u2502 \u2514\u2500\u2500 *.rblk # Content-addressed blocks \u2502 \u251c\u2500\u2500 chain/ \u2502 \u2502 \u251c\u2500\u2500 chain.rchn # Append-only chain file \u2502 \u2502 \u2514\u2500\u2500 chain.rchn.sig \u2502 \u2514\u2500\u2500 _meta/ \u2502 \u251c\u2500\u2500 ledger.cbor # Ledger metadata \u2502 \u251c\u2500\u2500 keys/ \u2502 \u2502 \u2514\u2500\u2500 pubkeys.cbor # Public keys for verification \u2502 \u2514\u2500\u2500 schema/ \u2502 \u2514\u2500\u2500 v2.cbor # Schema definitions 2.1 File Naming Convention Pattern Description Example {MM}.rseg Segment for minutes MM-MM+9 00.rseg , 10.rseg {type}.ridx Index by type time.ridx , object.ridx hour.rroot Signed hour root Single file per hour {hash}.rblk Content-addressed block a1b2c3...d4.rblk 3. Segment Files (.rseg) 3.1 Format Overview Segment files are append-only containers holding multiple records, inspired by WARC ISO 28500 [1]. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Segment Header (fixed) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record 0: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record 1: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record N: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Segment Footer (on finalization) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 3.2 Segment Header CBOR Array (tag: \"ritma-seg@1.0\"): [ \"ritma-seg@1.0\", // [0] Format tag 2, // [1] Version \"2026-01-19T10:00:00Z\", // [2] Start timestamp (ISO 8601) \"node-abc123\", // [3] Node ID \"2026011910\", // [4] Shard ID (YYYYMMDDHH) 0, // [5] Segment index (0-5 for 10-min segments) <prev_segment_hash>, // [6] Previous segment hash (32 bytes) or null {} // [7] Extensions (reserved) ] Size: ~150 bytes typical 3.3 Record Structure Each record follows the WARC-inspired framing: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Length Prefix (LEB128 varint) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record Header (CBOR) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record Body (CBOR, optionally compressed) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 3.3.1 Record Header CBOR Array (tag: \"ritma-rec@1.0\"): [ \"ritma-rec@1.0\", // [0] Record tag <record_type>, // [1] Type enum (see below) <record_id>, // [2] UUID or sequential ID <timestamp_ns>, // [3] Nanosecond timestamp (i64) <body_length>, // [4] Body length in bytes <body_hash>, // [5] SHA-256 of body (32 bytes) <compression>, // [6] Compression: 0=none, 1=zstd {} // [7] Extensions ] 3.3.2 Record Types Code Type Description 0 segment_info Segment metadata (first record) 1 event Canonical event atom 2 custody Custody transfer record 3 snapshot State snapshot chunk 4 block_ref Reference to content-addressed block 5 micro_root Micro-window Merkle root 6 attestation TPM or external attestation 7 metadata Arbitrary metadata 8 segment_seal Segment finalization (last record) 3.4 Segment Footer (Seal Record) When a segment is finalized: CBOR Array (tag: \"ritma-seal@1.0\"): [ \"ritma-seal@1.0\", // [0] Seal tag <record_count>, // [1] Total records in segment <byte_count>, // [2] Total bytes (excluding footer) <end_timestamp>, // [3] Last record timestamp <segment_hash>, // [4] SHA-256 of segment (excluding footer) <mmr_peaks>, // [5] MMR peaks array for records <signature> // [6] Ed25519 signature of [0..5] ] 3.5 Append-Only Guarantee Per RFC 6962 Section 3 [4]: \"A log is a single, ever-growing, append-only Merkle Tree\" RTSL enforces this by: 1. Segments are write-once after sealing 2. Each segment references previous segment hash 3. Segment seals are signed 4. MMR structure allows efficient append proofs 4. Index Files (.ridx) Indexes are rebuildable from segments (crash-safe design per Git [3]). 4.1 Time Index (time.ridx) Maps timestamps to segment offsets for fast time-range queries. CBOR Map: { \"tag\": \"ritma-idx-time@1.0\", \"shard\": \"2026011910\", \"entries\": [ // Sorted by timestamp [<timestamp_ns>, <segment_idx>, <byte_offset>, <record_len>], [<timestamp_ns>, <segment_idx>, <byte_offset>, <record_len>], ... ], \"built_at\": <timestamp>, \"segment_hashes\": [<hash0>, <hash1>, ...] // For validation } 4.2 Object Index (object.ridx) Maps object/entity IDs to all their occurrences. CBOR Map: { \"tag\": \"ritma-idx-object@1.0\", \"shard\": \"2026011910\", \"entries\": { \"<object_id>\": [ [<segment_idx>, <byte_offset>, <record_len>, <timestamp_ns>], ... ], ... } } 4.3 Hash Index (hash.ridx) Maps content hashes to offsets (for deduplication). CBOR Map: { \"tag\": \"ritma-idx-hash@1.0\", \"shard\": \"2026011910\", \"entries\": { \"<sha256_hex>\": [<segment_idx>, <byte_offset>], ... } } 5. Root Files (.rroot) 5.1 Hour Root Structure Per RFC 9162 Section 4.10 (Signed Tree Head) [5]: CBOR Array (tag: \"ritma-hour-root@2.0\"): [ \"ritma-hour-root@2.0\", // [0] Tag \"2026011910\", // [1] Shard ID \"node-abc123\", // [2] Node ID <timestamp>, // [3] Signing timestamp <tree_size>, // [4] Number of records in hour <mmr_root>, // [5] MMR root hash (32 bytes) <segment_roots>, // [6] Array of segment seal hashes <prev_hour_root>, // [7] Previous hour root hash <extensions> // [8] Reserved ] 5.2 Signature File (.rroot.sig) CBOR Array (tag: \"ritma-sig@1.0\"): [ \"ritma-sig@1.0\", \"hour_root\", // Signed artifact type \"<key_id>\", // Signing key identifier <signature> // Ed25519 signature (64 bytes) ] 6. Merkle Structure 6.1 Merkle Mountain Range (MMR) RTSL uses MMR instead of balanced Merkle trees because: Append-only friendly : No rebalancing needed (per Grin [8]) Efficient proofs : O(log n) inclusion proofs Incremental updates : Only new peaks computed on append Height 3: 14 / \\ Height 2: 6 13 / \\ / \\ Height 1: 2 5 9 12 /\\ /\\ /\\ /\\ Height 0: 0 1 3 4 7 8 10 11 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Leaves (records) 6.2 Hash Function Per RFC 9162 Section 2.1 [5]: Leaf hash: H(0x00 || record_bytes) Internal hash: H(0x01 || left_hash || right_hash) Where H = SHA-256 (FIPS 180-4). 6.3 Proof Structure Inclusion proof for record at position m in tree of size n : CBOR Array (tag: \"ritma-proof@1.0\"): [ \"ritma-proof@1.0\", <leaf_index>, // Position in MMR <tree_size>, // MMR size at proof time <path>, // Array of sibling hashes <peak_hashes> // MMR peaks for verification ] 7. Sharding Strategy Per Sigstore/Rekor sharding best practices [7]: 7.1 Shard Boundaries Shard Level ID Format Duration Use Case Hour YYYYMMDDHH 1 hour Default production Day YYYYMMDD 24 hours Low-volume systems Minute YYYYMMDDHHmm 1 minute High-volume systems 7.2 Shard Lifecycle ACTIVE \u2192 SEALING \u2192 SEALED \u2192 ARCHIVED \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Cold storage \u2502 \u2502 \u2514\u2500\u2500 Immutable, verified \u2502 \u2514\u2500\u2500 Finalizing, no new writes \u2514\u2500\u2500 Accepting writes 7.3 Cross-Shard Chain The chain.rchn file links shards: CBOR Array (tag: \"ritma-chain@2.0\"): [ \"ritma-chain@2.0\", [ // Each entry links to previous { \"shard\": \"2026011909\", \"hour_root\": <hash>, \"prev_chain_hash\": <hash>, \"chain_hash\": <hash>, \"timestamp\": <ts>, \"signature\": <sig> }, { \"shard\": \"2026011910\", \"hour_root\": <hash>, \"prev_chain_hash\": <hash>, // Points to 2026011909 \"chain_hash\": <hash>, \"timestamp\": <ts>, \"signature\": <sig> }, ... ] ] 8. Content-Addressed Blocks Per IPLD CAR specification [9]: 8.1 Block Format Large payloads are stored as content-addressed blocks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Block Header (CBOR) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Block Data (raw bytes, may be zstd) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Header: CBOR Array (tag: \"ritma-blk@1.0\"): [ \"ritma-blk@1.0\", <content_hash>, // SHA-256 of uncompressed data <uncompressed_size>, <compressed_size>, // 0 if not compressed <codec> // 0=raw, 1=cbor, 2=json ] 8.2 Block References Records reference blocks by hash: CBOR Array (tag: \"ritma-blkref@1.0\"): [ \"ritma-blkref@1.0\", <content_hash>, // Reference to block <block_type>, // What the block contains <metadata> // Type-specific metadata ] 8.3 Deduplication Per Git packfile design [3]: - Identical content \u2192 same hash \u2192 stored once - Similar content \u2192 delta compression (future) 9. Locator System Every record has a unique Locator (LOC) : 9.1 LOC Format LOC := shard:segment:offset:length Example: 2026011910:00:4096:512 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Record length (bytes) \u2502 \u2502 \u2514\u2500\u2500 Byte offset in segment \u2502 \u2514\u2500\u2500 Segment index (00-50) \u2514\u2500\u2500 Shard ID (hour) 9.2 LOC URI ritma://node-abc123/2026011910/00/4096/512 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Length \u2502 \u2502 \u2502 \u2514\u2500\u2500 Offset \u2502 \u2502 \u2514\u2500\u2500 Segment \u2502 \u2514\u2500\u2500 Shard \u2514\u2500\u2500 Node ID 9.3 LOC Resolution fn resolve_loc(ledger: &Ledger, loc: &Loc) -> Result<Record> { let shard = ledger.get_shard(&loc.shard)?; let segment = shard.get_segment(loc.segment)?; let record = segment.read_at(loc.offset, loc.length)?; Ok(record) } 10. Verification Protocol 10.1 Offline Verification Steps Segment Integrity Verify each segment's seal signature Recompute segment hash, compare to seal Verify prev_segment_hash chain MMR Verification Rebuild MMR from segment records Compare peaks to sealed peaks Verify hour root matches MMR root Chain Verification Verify hour root signatures Verify prev_hour_root linkage Verify chain.rchn consistency Record Verification For specific record: compute inclusion proof Verify proof against hour root 10.2 Inclusion Proof Verification Per RFC 9162 Section 2.1.3 [5]: fn verify_inclusion( record: &[u8], proof: &InclusionProof, root: &[u8; 32] ) -> bool { let leaf_hash = sha256(&[0x00, record].concat()); let mut current = leaf_hash; for (i, sibling) in proof.path.iter().enumerate() { let bit = (proof.leaf_index >> i) & 1; current = if bit == 0 { sha256(&[0x01, &current, sibling].concat()) } else { sha256(&[0x01, sibling, &current].concat()) }; } // Combine with MMR peaks current == *root } 11. Compression 11.1 Strategy Per WARC Annex D [1]: Level Compression Use Case Record Optional zstd per record Mixed content Segment Whole-segment gzip Archival Block zstd for large blocks Snapshots 11.2 Record-Level Compression Record Header: compression = 1 (zstd) Record Body: zstd-compressed CBOR 11.3 Segment-Level Compression For archival, entire .rseg can be gzip-wrapped: - Filename: 00.rseg.gz - Random access via gzip member boundaries (per WARC) 12. Cold Storage & Retention 12.1 Tiered Storage Tier Content Retention Access Hot Last 7 days segments Always Immediate Warm Last 90 days roots + indexes Always Fast Cold Older segments Per policy Minutes Archive Sealed shards Years Hours 12.2 Minimal Verification Set Even with cold segments, verification possible with: - chain.rchn (tiny, always hot) - hour.rroot files (tiny, always hot) - Specific segment (fetch on demand) 13. Court Admissibility Per NIST IR 8387 [6] and digital forensics standards: 13.1 Chain of Custody RTSL provides: - Immutable records : Append-only, signed segments - Precise timestamps : Nanosecond resolution - Cryptographic binding : Every record in Merkle tree - Verifiable history : Inclusion proofs 13.2 Evidence Export ritma export --loc 2026011910:00:4096:512 --format court-package Output: \u251c\u2500\u2500 record.cbor # The actual record \u251c\u2500\u2500 inclusion_proof.cbor # Merkle proof \u251c\u2500\u2500 hour_root.cbor # Signed root \u251c\u2500\u2500 chain_excerpt.cbor # Relevant chain entries \u251c\u2500\u2500 verification_report.pdf # Human-readable report \u2514\u2500\u2500 manifest.json # Package manifest 13.3 Verification Report RITMA EVIDENCE VERIFICATION REPORT ================================== Record LOC: 2026011910:00:4096:512 Record Hash: a1b2c3... Timestamp: 2026-01-19T10:00:37.123456789Z VERIFICATION RESULTS: [\u2713] Record hash matches content [\u2713] Inclusion proof valid against hour root [\u2713] Hour root signature valid (key: node-abc123-ed25519) [\u2713] Chain linkage verified (prev: 2026011909) [\u2713] TPM attestation binding verified CHAIN OF CUSTODY: - Created: 2026-01-19T10:00:37Z by node-abc123 - Sealed: 2026-01-19T10:10:00Z - Verified: 2026-01-19T17:56:00Z by verifier-xyz 14. Migration from v1 14.1 Compatibility v1 Artifact v2 Equivalent windows/YYYY/MM/DD/HH/micro/*.cbor shards/YYYY/MM/DD/HH/segments/*.rseg windows/.../proofs/hour_root.cbor shards/.../roots/hour.rroot windows/.../proofs/chain.cbor chain/chain.rchn _meta/keys/pubkeys.cbor _meta/keys/pubkeys.cbor (unchanged) 14.2 Migration Tool ritma migrate-ledger --from v1 --to v2 --input ./RITMA_OUT --output ./ledger 15. References [WARC ISO 28500] The WARC Format 1.1, IIPC. https://iipc.github.io/warc-specifications/specifications/warc-format/warc-1.1/ [WAL] Write-Ahead Logging. SQLite. https://sqlite.org/wal.html [Git Packfiles] Git Internals - Packfiles. https://git-scm.com/book/en/v2/Git-Internals-Packfiles [RFC 6962] Certificate Transparency. https://www.rfc-editor.org/rfc/rfc6962.html [RFC 9162] Certificate Transparency Version 2.0. https://www.rfc-editor.org/rfc/rfc9162.html [NIST IR 8387] Digital Evidence Preservation. https://nvlpubs.nist.gov/nistpubs/ir/2022/NIST.IR.8387.pdf [Sigstore Sharding] Rekor Log Sharding. https://docs.sigstore.dev/logging/sharding/ [Grin MMR] Merkle Mountain Ranges. https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/ [IPLD CAR] Content Addressable aRchives v1. https://ipld.io/specs/transport/car/carv1/ 16. Production Readiness Checklist This section defines 10 hard requirements for production stability. Each requirement includes MUST/SHOULD levels, failure modes, and RTSL implementation details. 16.1 Crash-Safe Writes (Atomic + Recoverable) Requirement: Power loss mid-write MUST NOT corrupt the ledger. Level Requirement RTSL Implementation MUST No partial records visible after crash Write-ahead: full record written before advancing offset pointer MUST Recovery without data loss Replay from last sealed segment + truncate incomplete records SHOULD Sub-second recovery time Index rebuild from segment headers only (not full scan) Implementation (No External DB): Write sequence: 1. Append [varint_len][header][body] to segment file 2. fsync() segment file 3. Update in-memory offset pointer 4. Periodically fsync() index file Recovery sequence: 1. Read segment header \u2192 get expected record count 2. Scan forward, validating each [varint_len][header][body] 3. Truncate at first invalid/incomplete record 4. Rebuild index from valid records Failure Modes: - Partial varint write \u2192 detected by invalid length, truncated - Partial record write \u2192 detected by length mismatch, truncated - Index corruption \u2192 rebuilt from segments (indexes are derived, not source of truth) References: SQLite WAL [2], ARIES recovery algorithm 16.2 Append-Only Immutability Requirement: Once written, records MUST NEVER be edited in place. Level Requirement RTSL Implementation MUST No in-place modification Segment files opened O_APPEND only MUST Corrections as new records correction record type with corrects_loc field MUST History always preserved Sealed segments are read-only (chmod 0444) SHOULD Detect tampering MMR root changes if any record modified Correction Record Format: [\"ritma-rec@1.0\", 9, <uuid>, <ts>, <len>, <hash>, 0, { \"corrects_loc\": \"2026011910:00:4096:512\", \"reason\": \"data_entry_error\", \"correction_type\": \"supersede\" // or \"void\", \"amend\" }] References: Event Sourcing patterns, RFC 6962 append-only logs 16.3 Deterministic Canonical Hashing Requirement: Same input MUST produce identical hash across all implementations. Level Requirement RTSL Implementation MUST Cross-language consistency RFC 8949 Core Deterministic Encoding MUST Reproducible hashes Canonical CBOR rules strictly enforced MUST No floating-point ambiguity Integers only for timestamps; floats banned in hashed fields Canonical CBOR Rules (per RFC 8949 \u00a74.2.1): 1. Preferred serialization (shortest form) 2. Map keys sorted by encoded byte order 3. No indefinite-length items 4. Integers: smallest encoding that fits 5. No duplicate map keys Hash Function: SHA-256 (FIPS 180-4), same as Certificate Transparency Test Vectors: Input: {\"b\": 2, \"a\": 1} Canonical CBOR: a2 61 61 01 61 62 02 (keys sorted: \"a\" before \"b\") SHA-256: 9f86d08... References: RFC 8949 \u00a74.2, FIDO CTAP2 canonical CBOR 16.4 Chain-of-Custody Correctness Requirement: Every event MUST link to previous, enabling instant gap/reorder detection. Level Requirement RTSL Implementation MUST Sequential numbering seq field in every record (per-segment, monotonic) MUST Hash chaining prev_record_hash in record header MUST Gap detection Verifier checks seq[i] == seq[i-1] + 1 MUST Double-write detection Same seq + different hash = error Record Linkage: Record N: seq=42, prev_hash=H(Record N-1), ... Record N+1: seq=43, prev_hash=H(Record N), ... Segment Linkage: Segment M: prev_segment_hash = H(Segment M-1 seal) Segment M+1: prev_segment_hash = H(Segment M seal) Verification Checks: - seq strictly increasing within segment - prev_record_hash matches computed hash of previous record - prev_segment_hash matches sealed hash of previous segment - No gaps in segment sequence (00, 10, 20, 30, 40, 50) 16.5 Scales Without Filesystem Pain Requirement: MUST handle months/years of data without \"millions of tiny files\" problem. Level Requirement RTSL Implementation MUST < 100 files per hour 6 segments + 3 indexes + 2 roots = 11 files/hour MUST No inode exhaustion Segments contain thousands of records each SHOULD < 1000 files per day ~264 files/day (11 \u00d7 24) SHOULD Predictable growth Linear with time, not with event count File Count Analysis: Per hour: 6 segments + 3 indexes + 2 roots + ~10 blocks = ~21 files Per day: ~504 files Per month: ~15,120 files Per year: ~183,960 files (manageable on any filesystem) Contrast with v1: v1: 1 file per micro-window (10s) = 360 files/hour = 8,640 files/day v2: 21 files/hour = 504 files/day (17x reduction) 16.6 Fast Tracing (O(1)-ish Lookup) Requirement: Given time or object_id, MUST jump to exact records without full scan. Level Requirement RTSL Implementation MUST Time \u2192 records in O(log n) time.ridx : sorted array, binary search MUST Object \u2192 records in O(1) object.ridx : hash map object_id \u2192 offsets SHOULD < 10ms for any lookup Index fits in memory for hot shards Index Structures (Simple Files, No DB): time.ridx (sorted array): { \"entries\": [ [1705665600000000000, 0, 0, 512], // ts_ns, seg, offset, len [1705665600100000000, 0, 512, 256], ... ] } Lookup: binary search on timestamp \u2192 segment + offset object.ridx (hash map): { \"entries\": { \"obj-abc123\": [[0, 1024, 512, ts1], [0, 2048, 256, ts2]], \"obj-def456\": [[1, 0, 1024, ts3]], ... } } Lookup: direct key access \u2192 list of (segment, offset, len, ts) 16.7 Multi-Level Provability Requirement: MUST support proofs at record, segment, hour, and chain levels. Level Proof Type What It Proves Size Record MMR inclusion \"Record X exists in segment S\" O(log n) hashes Segment Seal signature \"Segment S was finalized by node N at time T\" 64 bytes Hour Root signature \"Hour H contains segments S1..S6 with root R\" 64 bytes Chain Chain linkage \"Hours H1\u2192H2\u2192...\u2192Hn form append-only sequence\" O(n) \u00d7 32 bytes Proof Generation: // Record inclusion proof fn prove_record(loc: &Loc) -> InclusionProof { let segment = load_segment(loc.shard, loc.segment); let mmr = segment.rebuild_mmr(); mmr.prove(loc.record_index) } // Verify: recompute root from proof, compare to signed hour root Future Extension: ZK proofs for \"state transitioned correctly\" (not in v1.0) 16.8 Selective Disclosure Exports (ProofPack Tiers) Requirement: MUST support tiered exports from minimal to full. Tier Contents Size Use Case Micro Roots + chain + specific record proofs ~10 KB Court exhibit, audit summary Mini Above + relevant segment(s) ~1 MB Incident investigation Full All segments + blocks for time range ~100 MB+ Complete forensic package Export Commands: # Micro: just prove one record existed ritma export --loc 2026011910:00:4096:512 --tier micro # Mini: include the segment containing the record ritma export --loc 2026011910:00:4096:512 --tier mini # Full: entire hour ritma export --shard 2026011910 --tier full Micro Export Contents: export/ \u251c\u2500\u2500 record.cbor # The specific record \u251c\u2500\u2500 proof.cbor # MMR inclusion proof \u251c\u2500\u2500 segment_seal.cbor # Segment seal (signed) \u251c\u2500\u2500 hour_root.cbor # Hour root (signed) \u251c\u2500\u2500 chain_excerpt.cbor # Relevant chain entries \u2514\u2500\u2500 manifest.json 16.9 Retention + Cold Storage Without Breaking Verification Requirement: MUST verify integrity even after moving segments to cold storage. Level Requirement RTSL Implementation MUST Verify without segments Keep roots + chain (tiny) forever MUST Prove record existed Inclusion proof works with just root SHOULD On-demand segment fetch LOC \u2192 fetch from cold storage if needed What to Keep Forever (Tiny): Per hour: hour.rroot (< 1 KB) + hour.rroot.sig (< 1 KB) Per year: ~17 MB of roots (trivial) What Can Be Archived/Deleted: segments/*.rseg \u2192 Archive to S3/Glacier after 90 days blocks/*.rblk \u2192 Archive after 90 days index/*.ridx \u2192 Rebuild from segments if needed Verification with Cold Segments: 1. User requests proof for LOC 2024011910:00:4096:512 2. System checks: segment in hot storage? No. 3. System fetches segment from cold storage (async) 4. System generates proof, returns to user 5. Proof verifies against always-hot hour root 16.10 Operational Observability + Self-Checks Requirement: MUST provide built-in health checks and diagnostics. CLI Commands: # Full verification ritma ledger doctor --path ./ledger Doctor Output: RITMA LEDGER HEALTH CHECK ========================= Path: ./ledger Format: RTSL v2 STRUCTURE CHECKS: [\u2713] CURRENT file exists and valid [\u2713] Chain file intact (1,234 entries) [\u2713] All shards have hour roots INTEGRITY CHECKS: [\u2713] Chain hash continuity verified [\u2713] All hour roots properly signed [\u2713] Segment seals verified (7,404 segments) [\u2713] MMR roots match sealed values INDEX CHECKS: [\u2713] time.ridx consistent with segments [\u2713] object.ridx consistent with segments [!] hash.ridx missing for shard 2026011823 (rebuildable) STORAGE METRICS: Total shards: 1,234 Total segments: 7,404 Total records: 12,456,789 Total size: 45.2 GB Hot storage: 12.1 GB (last 7 days) Cold storage: 33.1 GB RECOMMENDATIONS: - Rebuild hash.ridx for shard 2026011823 - Consider archiving shards older than 2025121910 Metrics Exposed: ritma_ledger_records_total{shard=\"2026011910\"} 12345 ritma_ledger_segments_total 7404 ritma_ledger_bytes_total 48573849234 ritma_ledger_last_seal_timestamp 1705665600 ritma_ledger_verification_errors_total 0 17. Design Principles: Lightweight & No External Dependencies RTSL is designed to be self-contained with no external database dependencies : Principle Implementation No embedded DB Plain files only (no RocksDB, SQLite, LMDB) No complex indexes Simple CBOR files, rebuildable from segments Minimal dependencies Only: SHA-256, Ed25519, CBOR, zstd Portable Works on any POSIX filesystem Inspectable cbor2json can read any file Why No Embedded Database: - RocksDB/LMDB add 10+ MB binary size - Complex failure modes (compaction, WAL, etc.) - Harder to inspect/debug - Overkill for append-only workload RTSL Approach: - Segments are the source of truth (append-only files) - Indexes are derived (rebuildable) - Roots are tiny (keep forever) - Everything is CBOR (human-inspectable with tools) Appendix A: ABNF Grammar ; Segment file rseg-file = segment-header *record segment-seal ; Record record = length-prefix record-header record-body length-prefix = varint record-header = cbor-array record-body = cbor-value / compressed-cbor ; Varint (LEB128) varint = 1*8OCTET ; CBOR types cbor-array = <per RFC 8949> cbor-value = <per RFC 8949> Appendix B: Example Segment Hex Dump 00000000: d9 d9 f7 88 6d 72 69 74 6d 61 2d 73 65 67 40 31 |....mritma-seg@1| 00000010: 2e 30 02 78 18 32 30 32 36 2d 30 31 2d 31 39 54 |.0.x.2026-01-19T| 00000020: 31 30 3a 30 30 3a 30 30 5a 6b 6e 6f 64 65 2d 61 |10:00:00Zknode-a| 00000030: 62 63 31 32 33 6a 32 30 32 36 30 31 31 39 31 30 |bc123j2026011910| ... Appendix C: CLI Examples # Write events to ledger ritma ledger write --event '{\"type\":\"file_access\",...}' # Query by time range ritma ledger query --from 2026-01-19T10:00:00Z --to 2026-01-19T11:00:00Z # Get inclusion proof ritma ledger prove --loc 2026011910:00:4096:512 # Verify entire ledger ritma ledger verify --path ./ledger # Export for court ritma ledger export --loc 2026011910:00:4096:512 --format court-package End of RTSL Specification v1.0","title":"RTSL Spec"},{"location":"RTSL_SPEC/#ritma-transparent-segment-ledger-rtsl-specification","text":"Version: 1.0 Status: Draft Date: 2026-01-19","title":"Ritma Transparent Segment Ledger (RTSL) Specification"},{"location":"RTSL_SPEC/#abstract","text":"RTSL (Ritma Transparent Segment Ledger) is a production-grade output format for forensic audit logs that combines: WARC-style append-only segments for stability and reduced filesystem operations Certificate Transparency (CT) Merkle proofs for cryptographic append-only guarantees Sigstore/Rekor sharding for infinite scalability IPLD CAR content-addressing for deduplication and efficient exports Git packfile delta compression for storage efficiency Merkle Mountain Range (MMR) for efficient append-only proofs This format replaces the current \"folder dump\" approach with a court-ready, production-stable, easily traceable archive system.","title":"Abstract"},{"location":"RTSL_SPEC/#table-of-contents","text":"Design Goals Directory Structure Segment Files (.rseg) Index Files (.ridx) Root Files (.rroot) Merkle Structure Sharding Strategy Content-Addressed Blocks Locator System Verification Protocol Compression Cold Storage & Retention Court Admissibility Migration from v1 References","title":"Table of Contents"},{"location":"RTSL_SPEC/#1-design-goals","text":"","title":"1. Design Goals"},{"location":"RTSL_SPEC/#11-stability-production-critical","text":"Problem (Current) Solution (RTSL) Source Millions of small files Append-only segment files WARC ISO 28500 [1] Filesystem exhaustion Few large files per hour WARC best practices Crash corruption Atomic segment finalization WAL pattern [2] Index corruption Rebuildable from segments Git packfile design [3]","title":"1.1 Stability (Production-Critical)"},{"location":"RTSL_SPEC/#12-traceability-court-ready","text":"Requirement RTSL Feature Source Precise event location LOC = (shard, segment, offset, len) WARC record offsets Tamper detection Merkle inclusion proofs RFC 6962/9162 [4][5] Append-only guarantee Signed Tree Heads (STH) Certificate Transparency Chain of custody Custody records in segments NIST IR 8387 [6]","title":"1.2 Traceability (Court-Ready)"},{"location":"RTSL_SPEC/#13-scalability-enterprise-grade","text":"Challenge Solution Source Unbounded growth Time-based sharding Sigstore/Rekor [7] Verification cost MMR for O(log n) proofs Grin MMR [8] Storage cost Delta compression + dedup Git packfiles [3] Export size Content-addressed blocks IPLD CAR [9]","title":"1.3 Scalability (Enterprise-Grade)"},{"location":"RTSL_SPEC/#2-directory-structure","text":"ledger/ \u251c\u2500\u2500 v2/ # Format version \u2502 \u251c\u2500\u2500 CURRENT # Active shard pointer \u2502 \u251c\u2500\u2500 shards/ \u2502 \u2502 \u2514\u2500\u2500 2026/ \u2502 \u2502 \u2514\u2500\u2500 01/ \u2502 \u2502 \u2514\u2500\u2500 19/ \u2502 \u2502 \u2514\u2500\u2500 10/ # Hour shard (YYYYMMDDHH) \u2502 \u2502 \u251c\u2500\u2500 segments/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 00.rseg # Minute 00-09 \u2502 \u2502 \u2502 \u251c\u2500\u2500 10.rseg # Minute 10-19 \u2502 \u2502 \u2502 \u251c\u2500\u2500 20.rseg # ... \u2502 \u2502 \u2502 \u251c\u2500\u2500 30.rseg \u2502 \u2502 \u2502 \u251c\u2500\u2500 40.rseg \u2502 \u2502 \u2502 \u2514\u2500\u2500 50.rseg \u2502 \u2502 \u251c\u2500\u2500 index/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 time.ridx # Time \u2192 offset index \u2502 \u2502 \u2502 \u251c\u2500\u2500 object.ridx # ObjectID \u2192 offsets \u2502 \u2502 \u2502 \u2514\u2500\u2500 hash.ridx # ContentHash \u2192 offset \u2502 \u2502 \u251c\u2500\u2500 roots/ \u2502 \u2502 \u2502 \u251c\u2500\u2500 hour.rroot # Signed hour root \u2502 \u2502 \u2502 \u2514\u2500\u2500 hour.rroot.sig \u2502 \u2502 \u2514\u2500\u2500 blocks/ \u2502 \u2502 \u2514\u2500\u2500 *.rblk # Content-addressed blocks \u2502 \u251c\u2500\u2500 chain/ \u2502 \u2502 \u251c\u2500\u2500 chain.rchn # Append-only chain file \u2502 \u2502 \u2514\u2500\u2500 chain.rchn.sig \u2502 \u2514\u2500\u2500 _meta/ \u2502 \u251c\u2500\u2500 ledger.cbor # Ledger metadata \u2502 \u251c\u2500\u2500 keys/ \u2502 \u2502 \u2514\u2500\u2500 pubkeys.cbor # Public keys for verification \u2502 \u2514\u2500\u2500 schema/ \u2502 \u2514\u2500\u2500 v2.cbor # Schema definitions","title":"2. Directory Structure"},{"location":"RTSL_SPEC/#21-file-naming-convention","text":"Pattern Description Example {MM}.rseg Segment for minutes MM-MM+9 00.rseg , 10.rseg {type}.ridx Index by type time.ridx , object.ridx hour.rroot Signed hour root Single file per hour {hash}.rblk Content-addressed block a1b2c3...d4.rblk","title":"2.1 File Naming Convention"},{"location":"RTSL_SPEC/#3-segment-files-rseg","text":"","title":"3. Segment Files (.rseg)"},{"location":"RTSL_SPEC/#31-format-overview","text":"Segment files are append-only containers holding multiple records, inspired by WARC ISO 28500 [1]. \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Segment Header (fixed) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record 0: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record 1: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record N: [varint len][Record Header][Record Body] \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Segment Footer (on finalization) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"3.1 Format Overview"},{"location":"RTSL_SPEC/#32-segment-header","text":"CBOR Array (tag: \"ritma-seg@1.0\"): [ \"ritma-seg@1.0\", // [0] Format tag 2, // [1] Version \"2026-01-19T10:00:00Z\", // [2] Start timestamp (ISO 8601) \"node-abc123\", // [3] Node ID \"2026011910\", // [4] Shard ID (YYYYMMDDHH) 0, // [5] Segment index (0-5 for 10-min segments) <prev_segment_hash>, // [6] Previous segment hash (32 bytes) or null {} // [7] Extensions (reserved) ] Size: ~150 bytes typical","title":"3.2 Segment Header"},{"location":"RTSL_SPEC/#33-record-structure","text":"Each record follows the WARC-inspired framing: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Length Prefix (LEB128 varint) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record Header (CBOR) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Record Body (CBOR, optionally compressed) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"3.3 Record Structure"},{"location":"RTSL_SPEC/#331-record-header","text":"CBOR Array (tag: \"ritma-rec@1.0\"): [ \"ritma-rec@1.0\", // [0] Record tag <record_type>, // [1] Type enum (see below) <record_id>, // [2] UUID or sequential ID <timestamp_ns>, // [3] Nanosecond timestamp (i64) <body_length>, // [4] Body length in bytes <body_hash>, // [5] SHA-256 of body (32 bytes) <compression>, // [6] Compression: 0=none, 1=zstd {} // [7] Extensions ]","title":"3.3.1 Record Header"},{"location":"RTSL_SPEC/#332-record-types","text":"Code Type Description 0 segment_info Segment metadata (first record) 1 event Canonical event atom 2 custody Custody transfer record 3 snapshot State snapshot chunk 4 block_ref Reference to content-addressed block 5 micro_root Micro-window Merkle root 6 attestation TPM or external attestation 7 metadata Arbitrary metadata 8 segment_seal Segment finalization (last record)","title":"3.3.2 Record Types"},{"location":"RTSL_SPEC/#34-segment-footer-seal-record","text":"When a segment is finalized: CBOR Array (tag: \"ritma-seal@1.0\"): [ \"ritma-seal@1.0\", // [0] Seal tag <record_count>, // [1] Total records in segment <byte_count>, // [2] Total bytes (excluding footer) <end_timestamp>, // [3] Last record timestamp <segment_hash>, // [4] SHA-256 of segment (excluding footer) <mmr_peaks>, // [5] MMR peaks array for records <signature> // [6] Ed25519 signature of [0..5] ]","title":"3.4 Segment Footer (Seal Record)"},{"location":"RTSL_SPEC/#35-append-only-guarantee","text":"Per RFC 6962 Section 3 [4]: \"A log is a single, ever-growing, append-only Merkle Tree\" RTSL enforces this by: 1. Segments are write-once after sealing 2. Each segment references previous segment hash 3. Segment seals are signed 4. MMR structure allows efficient append proofs","title":"3.5 Append-Only Guarantee"},{"location":"RTSL_SPEC/#4-index-files-ridx","text":"Indexes are rebuildable from segments (crash-safe design per Git [3]).","title":"4. Index Files (.ridx)"},{"location":"RTSL_SPEC/#41-time-index-timeridx","text":"Maps timestamps to segment offsets for fast time-range queries. CBOR Map: { \"tag\": \"ritma-idx-time@1.0\", \"shard\": \"2026011910\", \"entries\": [ // Sorted by timestamp [<timestamp_ns>, <segment_idx>, <byte_offset>, <record_len>], [<timestamp_ns>, <segment_idx>, <byte_offset>, <record_len>], ... ], \"built_at\": <timestamp>, \"segment_hashes\": [<hash0>, <hash1>, ...] // For validation }","title":"4.1 Time Index (time.ridx)"},{"location":"RTSL_SPEC/#42-object-index-objectridx","text":"Maps object/entity IDs to all their occurrences. CBOR Map: { \"tag\": \"ritma-idx-object@1.0\", \"shard\": \"2026011910\", \"entries\": { \"<object_id>\": [ [<segment_idx>, <byte_offset>, <record_len>, <timestamp_ns>], ... ], ... } }","title":"4.2 Object Index (object.ridx)"},{"location":"RTSL_SPEC/#43-hash-index-hashridx","text":"Maps content hashes to offsets (for deduplication). CBOR Map: { \"tag\": \"ritma-idx-hash@1.0\", \"shard\": \"2026011910\", \"entries\": { \"<sha256_hex>\": [<segment_idx>, <byte_offset>], ... } }","title":"4.3 Hash Index (hash.ridx)"},{"location":"RTSL_SPEC/#5-root-files-rroot","text":"","title":"5. Root Files (.rroot)"},{"location":"RTSL_SPEC/#51-hour-root-structure","text":"Per RFC 9162 Section 4.10 (Signed Tree Head) [5]: CBOR Array (tag: \"ritma-hour-root@2.0\"): [ \"ritma-hour-root@2.0\", // [0] Tag \"2026011910\", // [1] Shard ID \"node-abc123\", // [2] Node ID <timestamp>, // [3] Signing timestamp <tree_size>, // [4] Number of records in hour <mmr_root>, // [5] MMR root hash (32 bytes) <segment_roots>, // [6] Array of segment seal hashes <prev_hour_root>, // [7] Previous hour root hash <extensions> // [8] Reserved ]","title":"5.1 Hour Root Structure"},{"location":"RTSL_SPEC/#52-signature-file-rrootsig","text":"CBOR Array (tag: \"ritma-sig@1.0\"): [ \"ritma-sig@1.0\", \"hour_root\", // Signed artifact type \"<key_id>\", // Signing key identifier <signature> // Ed25519 signature (64 bytes) ]","title":"5.2 Signature File (.rroot.sig)"},{"location":"RTSL_SPEC/#6-merkle-structure","text":"","title":"6. Merkle Structure"},{"location":"RTSL_SPEC/#61-merkle-mountain-range-mmr","text":"RTSL uses MMR instead of balanced Merkle trees because: Append-only friendly : No rebalancing needed (per Grin [8]) Efficient proofs : O(log n) inclusion proofs Incremental updates : Only new peaks computed on append Height 3: 14 / \\ Height 2: 6 13 / \\ / \\ Height 1: 2 5 9 12 /\\ /\\ /\\ /\\ Height 0: 0 1 3 4 7 8 10 11 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Leaves (records)","title":"6.1 Merkle Mountain Range (MMR)"},{"location":"RTSL_SPEC/#62-hash-function","text":"Per RFC 9162 Section 2.1 [5]: Leaf hash: H(0x00 || record_bytes) Internal hash: H(0x01 || left_hash || right_hash) Where H = SHA-256 (FIPS 180-4).","title":"6.2 Hash Function"},{"location":"RTSL_SPEC/#63-proof-structure","text":"Inclusion proof for record at position m in tree of size n : CBOR Array (tag: \"ritma-proof@1.0\"): [ \"ritma-proof@1.0\", <leaf_index>, // Position in MMR <tree_size>, // MMR size at proof time <path>, // Array of sibling hashes <peak_hashes> // MMR peaks for verification ]","title":"6.3 Proof Structure"},{"location":"RTSL_SPEC/#7-sharding-strategy","text":"Per Sigstore/Rekor sharding best practices [7]:","title":"7. Sharding Strategy"},{"location":"RTSL_SPEC/#71-shard-boundaries","text":"Shard Level ID Format Duration Use Case Hour YYYYMMDDHH 1 hour Default production Day YYYYMMDD 24 hours Low-volume systems Minute YYYYMMDDHHmm 1 minute High-volume systems","title":"7.1 Shard Boundaries"},{"location":"RTSL_SPEC/#72-shard-lifecycle","text":"ACTIVE \u2192 SEALING \u2192 SEALED \u2192 ARCHIVED \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Cold storage \u2502 \u2502 \u2514\u2500\u2500 Immutable, verified \u2502 \u2514\u2500\u2500 Finalizing, no new writes \u2514\u2500\u2500 Accepting writes","title":"7.2 Shard Lifecycle"},{"location":"RTSL_SPEC/#73-cross-shard-chain","text":"The chain.rchn file links shards: CBOR Array (tag: \"ritma-chain@2.0\"): [ \"ritma-chain@2.0\", [ // Each entry links to previous { \"shard\": \"2026011909\", \"hour_root\": <hash>, \"prev_chain_hash\": <hash>, \"chain_hash\": <hash>, \"timestamp\": <ts>, \"signature\": <sig> }, { \"shard\": \"2026011910\", \"hour_root\": <hash>, \"prev_chain_hash\": <hash>, // Points to 2026011909 \"chain_hash\": <hash>, \"timestamp\": <ts>, \"signature\": <sig> }, ... ] ]","title":"7.3 Cross-Shard Chain"},{"location":"RTSL_SPEC/#8-content-addressed-blocks","text":"Per IPLD CAR specification [9]:","title":"8. Content-Addressed Blocks"},{"location":"RTSL_SPEC/#81-block-format","text":"Large payloads are stored as content-addressed blocks: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Block Header (CBOR) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Block Data (raw bytes, may be zstd) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Header: CBOR Array (tag: \"ritma-blk@1.0\"): [ \"ritma-blk@1.0\", <content_hash>, // SHA-256 of uncompressed data <uncompressed_size>, <compressed_size>, // 0 if not compressed <codec> // 0=raw, 1=cbor, 2=json ]","title":"8.1 Block Format"},{"location":"RTSL_SPEC/#82-block-references","text":"Records reference blocks by hash: CBOR Array (tag: \"ritma-blkref@1.0\"): [ \"ritma-blkref@1.0\", <content_hash>, // Reference to block <block_type>, // What the block contains <metadata> // Type-specific metadata ]","title":"8.2 Block References"},{"location":"RTSL_SPEC/#83-deduplication","text":"Per Git packfile design [3]: - Identical content \u2192 same hash \u2192 stored once - Similar content \u2192 delta compression (future)","title":"8.3 Deduplication"},{"location":"RTSL_SPEC/#9-locator-system","text":"Every record has a unique Locator (LOC) :","title":"9. Locator System"},{"location":"RTSL_SPEC/#91-loc-format","text":"LOC := shard:segment:offset:length Example: 2026011910:00:4096:512 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Record length (bytes) \u2502 \u2502 \u2514\u2500\u2500 Byte offset in segment \u2502 \u2514\u2500\u2500 Segment index (00-50) \u2514\u2500\u2500 Shard ID (hour)","title":"9.1 LOC Format"},{"location":"RTSL_SPEC/#92-loc-uri","text":"ritma://node-abc123/2026011910/00/4096/512 \u2502 \u2502 \u2502 \u2502 \u2514\u2500\u2500 Length \u2502 \u2502 \u2502 \u2514\u2500\u2500 Offset \u2502 \u2502 \u2514\u2500\u2500 Segment \u2502 \u2514\u2500\u2500 Shard \u2514\u2500\u2500 Node ID","title":"9.2 LOC URI"},{"location":"RTSL_SPEC/#93-loc-resolution","text":"fn resolve_loc(ledger: &Ledger, loc: &Loc) -> Result<Record> { let shard = ledger.get_shard(&loc.shard)?; let segment = shard.get_segment(loc.segment)?; let record = segment.read_at(loc.offset, loc.length)?; Ok(record) }","title":"9.3 LOC Resolution"},{"location":"RTSL_SPEC/#10-verification-protocol","text":"","title":"10. Verification Protocol"},{"location":"RTSL_SPEC/#101-offline-verification-steps","text":"Segment Integrity Verify each segment's seal signature Recompute segment hash, compare to seal Verify prev_segment_hash chain MMR Verification Rebuild MMR from segment records Compare peaks to sealed peaks Verify hour root matches MMR root Chain Verification Verify hour root signatures Verify prev_hour_root linkage Verify chain.rchn consistency Record Verification For specific record: compute inclusion proof Verify proof against hour root","title":"10.1 Offline Verification Steps"},{"location":"RTSL_SPEC/#102-inclusion-proof-verification","text":"Per RFC 9162 Section 2.1.3 [5]: fn verify_inclusion( record: &[u8], proof: &InclusionProof, root: &[u8; 32] ) -> bool { let leaf_hash = sha256(&[0x00, record].concat()); let mut current = leaf_hash; for (i, sibling) in proof.path.iter().enumerate() { let bit = (proof.leaf_index >> i) & 1; current = if bit == 0 { sha256(&[0x01, &current, sibling].concat()) } else { sha256(&[0x01, sibling, &current].concat()) }; } // Combine with MMR peaks current == *root }","title":"10.2 Inclusion Proof Verification"},{"location":"RTSL_SPEC/#11-compression","text":"","title":"11. Compression"},{"location":"RTSL_SPEC/#111-strategy","text":"Per WARC Annex D [1]: Level Compression Use Case Record Optional zstd per record Mixed content Segment Whole-segment gzip Archival Block zstd for large blocks Snapshots","title":"11.1 Strategy"},{"location":"RTSL_SPEC/#112-record-level-compression","text":"Record Header: compression = 1 (zstd) Record Body: zstd-compressed CBOR","title":"11.2 Record-Level Compression"},{"location":"RTSL_SPEC/#113-segment-level-compression","text":"For archival, entire .rseg can be gzip-wrapped: - Filename: 00.rseg.gz - Random access via gzip member boundaries (per WARC)","title":"11.3 Segment-Level Compression"},{"location":"RTSL_SPEC/#12-cold-storage-retention","text":"","title":"12. Cold Storage &amp; Retention"},{"location":"RTSL_SPEC/#121-tiered-storage","text":"Tier Content Retention Access Hot Last 7 days segments Always Immediate Warm Last 90 days roots + indexes Always Fast Cold Older segments Per policy Minutes Archive Sealed shards Years Hours","title":"12.1 Tiered Storage"},{"location":"RTSL_SPEC/#122-minimal-verification-set","text":"Even with cold segments, verification possible with: - chain.rchn (tiny, always hot) - hour.rroot files (tiny, always hot) - Specific segment (fetch on demand)","title":"12.2 Minimal Verification Set"},{"location":"RTSL_SPEC/#13-court-admissibility","text":"Per NIST IR 8387 [6] and digital forensics standards:","title":"13. Court Admissibility"},{"location":"RTSL_SPEC/#131-chain-of-custody","text":"RTSL provides: - Immutable records : Append-only, signed segments - Precise timestamps : Nanosecond resolution - Cryptographic binding : Every record in Merkle tree - Verifiable history : Inclusion proofs","title":"13.1 Chain of Custody"},{"location":"RTSL_SPEC/#132-evidence-export","text":"ritma export --loc 2026011910:00:4096:512 --format court-package Output: \u251c\u2500\u2500 record.cbor # The actual record \u251c\u2500\u2500 inclusion_proof.cbor # Merkle proof \u251c\u2500\u2500 hour_root.cbor # Signed root \u251c\u2500\u2500 chain_excerpt.cbor # Relevant chain entries \u251c\u2500\u2500 verification_report.pdf # Human-readable report \u2514\u2500\u2500 manifest.json # Package manifest","title":"13.2 Evidence Export"},{"location":"RTSL_SPEC/#133-verification-report","text":"RITMA EVIDENCE VERIFICATION REPORT ================================== Record LOC: 2026011910:00:4096:512 Record Hash: a1b2c3... Timestamp: 2026-01-19T10:00:37.123456789Z VERIFICATION RESULTS: [\u2713] Record hash matches content [\u2713] Inclusion proof valid against hour root [\u2713] Hour root signature valid (key: node-abc123-ed25519) [\u2713] Chain linkage verified (prev: 2026011909) [\u2713] TPM attestation binding verified CHAIN OF CUSTODY: - Created: 2026-01-19T10:00:37Z by node-abc123 - Sealed: 2026-01-19T10:10:00Z - Verified: 2026-01-19T17:56:00Z by verifier-xyz","title":"13.3 Verification Report"},{"location":"RTSL_SPEC/#14-migration-from-v1","text":"","title":"14. Migration from v1"},{"location":"RTSL_SPEC/#141-compatibility","text":"v1 Artifact v2 Equivalent windows/YYYY/MM/DD/HH/micro/*.cbor shards/YYYY/MM/DD/HH/segments/*.rseg windows/.../proofs/hour_root.cbor shards/.../roots/hour.rroot windows/.../proofs/chain.cbor chain/chain.rchn _meta/keys/pubkeys.cbor _meta/keys/pubkeys.cbor (unchanged)","title":"14.1 Compatibility"},{"location":"RTSL_SPEC/#142-migration-tool","text":"ritma migrate-ledger --from v1 --to v2 --input ./RITMA_OUT --output ./ledger","title":"14.2 Migration Tool"},{"location":"RTSL_SPEC/#15-references","text":"[WARC ISO 28500] The WARC Format 1.1, IIPC. https://iipc.github.io/warc-specifications/specifications/warc-format/warc-1.1/ [WAL] Write-Ahead Logging. SQLite. https://sqlite.org/wal.html [Git Packfiles] Git Internals - Packfiles. https://git-scm.com/book/en/v2/Git-Internals-Packfiles [RFC 6962] Certificate Transparency. https://www.rfc-editor.org/rfc/rfc6962.html [RFC 9162] Certificate Transparency Version 2.0. https://www.rfc-editor.org/rfc/rfc9162.html [NIST IR 8387] Digital Evidence Preservation. https://nvlpubs.nist.gov/nistpubs/ir/2022/NIST.IR.8387.pdf [Sigstore Sharding] Rekor Log Sharding. https://docs.sigstore.dev/logging/sharding/ [Grin MMR] Merkle Mountain Ranges. https://docs.grin.mw/wiki/chain-state/merkle-mountain-range/ [IPLD CAR] Content Addressable aRchives v1. https://ipld.io/specs/transport/car/carv1/","title":"15. References"},{"location":"RTSL_SPEC/#16-production-readiness-checklist","text":"This section defines 10 hard requirements for production stability. Each requirement includes MUST/SHOULD levels, failure modes, and RTSL implementation details.","title":"16. Production Readiness Checklist"},{"location":"RTSL_SPEC/#161-crash-safe-writes-atomic-recoverable","text":"Requirement: Power loss mid-write MUST NOT corrupt the ledger. Level Requirement RTSL Implementation MUST No partial records visible after crash Write-ahead: full record written before advancing offset pointer MUST Recovery without data loss Replay from last sealed segment + truncate incomplete records SHOULD Sub-second recovery time Index rebuild from segment headers only (not full scan) Implementation (No External DB): Write sequence: 1. Append [varint_len][header][body] to segment file 2. fsync() segment file 3. Update in-memory offset pointer 4. Periodically fsync() index file Recovery sequence: 1. Read segment header \u2192 get expected record count 2. Scan forward, validating each [varint_len][header][body] 3. Truncate at first invalid/incomplete record 4. Rebuild index from valid records Failure Modes: - Partial varint write \u2192 detected by invalid length, truncated - Partial record write \u2192 detected by length mismatch, truncated - Index corruption \u2192 rebuilt from segments (indexes are derived, not source of truth) References: SQLite WAL [2], ARIES recovery algorithm","title":"16.1 Crash-Safe Writes (Atomic + Recoverable)"},{"location":"RTSL_SPEC/#162-append-only-immutability","text":"Requirement: Once written, records MUST NEVER be edited in place. Level Requirement RTSL Implementation MUST No in-place modification Segment files opened O_APPEND only MUST Corrections as new records correction record type with corrects_loc field MUST History always preserved Sealed segments are read-only (chmod 0444) SHOULD Detect tampering MMR root changes if any record modified Correction Record Format: [\"ritma-rec@1.0\", 9, <uuid>, <ts>, <len>, <hash>, 0, { \"corrects_loc\": \"2026011910:00:4096:512\", \"reason\": \"data_entry_error\", \"correction_type\": \"supersede\" // or \"void\", \"amend\" }] References: Event Sourcing patterns, RFC 6962 append-only logs","title":"16.2 Append-Only Immutability"},{"location":"RTSL_SPEC/#163-deterministic-canonical-hashing","text":"Requirement: Same input MUST produce identical hash across all implementations. Level Requirement RTSL Implementation MUST Cross-language consistency RFC 8949 Core Deterministic Encoding MUST Reproducible hashes Canonical CBOR rules strictly enforced MUST No floating-point ambiguity Integers only for timestamps; floats banned in hashed fields Canonical CBOR Rules (per RFC 8949 \u00a74.2.1): 1. Preferred serialization (shortest form) 2. Map keys sorted by encoded byte order 3. No indefinite-length items 4. Integers: smallest encoding that fits 5. No duplicate map keys Hash Function: SHA-256 (FIPS 180-4), same as Certificate Transparency Test Vectors: Input: {\"b\": 2, \"a\": 1} Canonical CBOR: a2 61 61 01 61 62 02 (keys sorted: \"a\" before \"b\") SHA-256: 9f86d08... References: RFC 8949 \u00a74.2, FIDO CTAP2 canonical CBOR","title":"16.3 Deterministic Canonical Hashing"},{"location":"RTSL_SPEC/#164-chain-of-custody-correctness","text":"Requirement: Every event MUST link to previous, enabling instant gap/reorder detection. Level Requirement RTSL Implementation MUST Sequential numbering seq field in every record (per-segment, monotonic) MUST Hash chaining prev_record_hash in record header MUST Gap detection Verifier checks seq[i] == seq[i-1] + 1 MUST Double-write detection Same seq + different hash = error Record Linkage: Record N: seq=42, prev_hash=H(Record N-1), ... Record N+1: seq=43, prev_hash=H(Record N), ... Segment Linkage: Segment M: prev_segment_hash = H(Segment M-1 seal) Segment M+1: prev_segment_hash = H(Segment M seal) Verification Checks: - seq strictly increasing within segment - prev_record_hash matches computed hash of previous record - prev_segment_hash matches sealed hash of previous segment - No gaps in segment sequence (00, 10, 20, 30, 40, 50)","title":"16.4 Chain-of-Custody Correctness"},{"location":"RTSL_SPEC/#165-scales-without-filesystem-pain","text":"Requirement: MUST handle months/years of data without \"millions of tiny files\" problem. Level Requirement RTSL Implementation MUST < 100 files per hour 6 segments + 3 indexes + 2 roots = 11 files/hour MUST No inode exhaustion Segments contain thousands of records each SHOULD < 1000 files per day ~264 files/day (11 \u00d7 24) SHOULD Predictable growth Linear with time, not with event count File Count Analysis: Per hour: 6 segments + 3 indexes + 2 roots + ~10 blocks = ~21 files Per day: ~504 files Per month: ~15,120 files Per year: ~183,960 files (manageable on any filesystem) Contrast with v1: v1: 1 file per micro-window (10s) = 360 files/hour = 8,640 files/day v2: 21 files/hour = 504 files/day (17x reduction)","title":"16.5 Scales Without Filesystem Pain"},{"location":"RTSL_SPEC/#166-fast-tracing-o1-ish-lookup","text":"Requirement: Given time or object_id, MUST jump to exact records without full scan. Level Requirement RTSL Implementation MUST Time \u2192 records in O(log n) time.ridx : sorted array, binary search MUST Object \u2192 records in O(1) object.ridx : hash map object_id \u2192 offsets SHOULD < 10ms for any lookup Index fits in memory for hot shards Index Structures (Simple Files, No DB): time.ridx (sorted array): { \"entries\": [ [1705665600000000000, 0, 0, 512], // ts_ns, seg, offset, len [1705665600100000000, 0, 512, 256], ... ] } Lookup: binary search on timestamp \u2192 segment + offset object.ridx (hash map): { \"entries\": { \"obj-abc123\": [[0, 1024, 512, ts1], [0, 2048, 256, ts2]], \"obj-def456\": [[1, 0, 1024, ts3]], ... } } Lookup: direct key access \u2192 list of (segment, offset, len, ts)","title":"16.6 Fast Tracing (O(1)-ish Lookup)"},{"location":"RTSL_SPEC/#167-multi-level-provability","text":"Requirement: MUST support proofs at record, segment, hour, and chain levels. Level Proof Type What It Proves Size Record MMR inclusion \"Record X exists in segment S\" O(log n) hashes Segment Seal signature \"Segment S was finalized by node N at time T\" 64 bytes Hour Root signature \"Hour H contains segments S1..S6 with root R\" 64 bytes Chain Chain linkage \"Hours H1\u2192H2\u2192...\u2192Hn form append-only sequence\" O(n) \u00d7 32 bytes Proof Generation: // Record inclusion proof fn prove_record(loc: &Loc) -> InclusionProof { let segment = load_segment(loc.shard, loc.segment); let mmr = segment.rebuild_mmr(); mmr.prove(loc.record_index) } // Verify: recompute root from proof, compare to signed hour root Future Extension: ZK proofs for \"state transitioned correctly\" (not in v1.0)","title":"16.7 Multi-Level Provability"},{"location":"RTSL_SPEC/#168-selective-disclosure-exports-proofpack-tiers","text":"Requirement: MUST support tiered exports from minimal to full. Tier Contents Size Use Case Micro Roots + chain + specific record proofs ~10 KB Court exhibit, audit summary Mini Above + relevant segment(s) ~1 MB Incident investigation Full All segments + blocks for time range ~100 MB+ Complete forensic package Export Commands: # Micro: just prove one record existed ritma export --loc 2026011910:00:4096:512 --tier micro # Mini: include the segment containing the record ritma export --loc 2026011910:00:4096:512 --tier mini # Full: entire hour ritma export --shard 2026011910 --tier full Micro Export Contents: export/ \u251c\u2500\u2500 record.cbor # The specific record \u251c\u2500\u2500 proof.cbor # MMR inclusion proof \u251c\u2500\u2500 segment_seal.cbor # Segment seal (signed) \u251c\u2500\u2500 hour_root.cbor # Hour root (signed) \u251c\u2500\u2500 chain_excerpt.cbor # Relevant chain entries \u2514\u2500\u2500 manifest.json","title":"16.8 Selective Disclosure Exports (ProofPack Tiers)"},{"location":"RTSL_SPEC/#169-retention-cold-storage-without-breaking-verification","text":"Requirement: MUST verify integrity even after moving segments to cold storage. Level Requirement RTSL Implementation MUST Verify without segments Keep roots + chain (tiny) forever MUST Prove record existed Inclusion proof works with just root SHOULD On-demand segment fetch LOC \u2192 fetch from cold storage if needed What to Keep Forever (Tiny): Per hour: hour.rroot (< 1 KB) + hour.rroot.sig (< 1 KB) Per year: ~17 MB of roots (trivial) What Can Be Archived/Deleted: segments/*.rseg \u2192 Archive to S3/Glacier after 90 days blocks/*.rblk \u2192 Archive after 90 days index/*.ridx \u2192 Rebuild from segments if needed Verification with Cold Segments: 1. User requests proof for LOC 2024011910:00:4096:512 2. System checks: segment in hot storage? No. 3. System fetches segment from cold storage (async) 4. System generates proof, returns to user 5. Proof verifies against always-hot hour root","title":"16.9 Retention + Cold Storage Without Breaking Verification"},{"location":"RTSL_SPEC/#1610-operational-observability-self-checks","text":"Requirement: MUST provide built-in health checks and diagnostics. CLI Commands: # Full verification ritma ledger doctor --path ./ledger Doctor Output: RITMA LEDGER HEALTH CHECK ========================= Path: ./ledger Format: RTSL v2 STRUCTURE CHECKS: [\u2713] CURRENT file exists and valid [\u2713] Chain file intact (1,234 entries) [\u2713] All shards have hour roots INTEGRITY CHECKS: [\u2713] Chain hash continuity verified [\u2713] All hour roots properly signed [\u2713] Segment seals verified (7,404 segments) [\u2713] MMR roots match sealed values INDEX CHECKS: [\u2713] time.ridx consistent with segments [\u2713] object.ridx consistent with segments [!] hash.ridx missing for shard 2026011823 (rebuildable) STORAGE METRICS: Total shards: 1,234 Total segments: 7,404 Total records: 12,456,789 Total size: 45.2 GB Hot storage: 12.1 GB (last 7 days) Cold storage: 33.1 GB RECOMMENDATIONS: - Rebuild hash.ridx for shard 2026011823 - Consider archiving shards older than 2025121910 Metrics Exposed: ritma_ledger_records_total{shard=\"2026011910\"} 12345 ritma_ledger_segments_total 7404 ritma_ledger_bytes_total 48573849234 ritma_ledger_last_seal_timestamp 1705665600 ritma_ledger_verification_errors_total 0","title":"16.10 Operational Observability + Self-Checks"},{"location":"RTSL_SPEC/#17-design-principles-lightweight-no-external-dependencies","text":"RTSL is designed to be self-contained with no external database dependencies : Principle Implementation No embedded DB Plain files only (no RocksDB, SQLite, LMDB) No complex indexes Simple CBOR files, rebuildable from segments Minimal dependencies Only: SHA-256, Ed25519, CBOR, zstd Portable Works on any POSIX filesystem Inspectable cbor2json can read any file Why No Embedded Database: - RocksDB/LMDB add 10+ MB binary size - Complex failure modes (compaction, WAL, etc.) - Harder to inspect/debug - Overkill for append-only workload RTSL Approach: - Segments are the source of truth (append-only files) - Indexes are derived (rebuildable) - Roots are tiny (keep forever) - Everything is CBOR (human-inspectable with tools)","title":"17. Design Principles: Lightweight &amp; No External Dependencies"},{"location":"RTSL_SPEC/#appendix-a-abnf-grammar","text":"; Segment file rseg-file = segment-header *record segment-seal ; Record record = length-prefix record-header record-body length-prefix = varint record-header = cbor-array record-body = cbor-value / compressed-cbor ; Varint (LEB128) varint = 1*8OCTET ; CBOR types cbor-array = <per RFC 8949> cbor-value = <per RFC 8949>","title":"Appendix A: ABNF Grammar"},{"location":"RTSL_SPEC/#appendix-b-example-segment-hex-dump","text":"00000000: d9 d9 f7 88 6d 72 69 74 6d 61 2d 73 65 67 40 31 |....mritma-seg@1| 00000010: 2e 30 02 78 18 32 30 32 36 2d 30 31 2d 31 39 54 |.0.x.2026-01-19T| 00000020: 31 30 3a 30 30 3a 30 30 5a 6b 6e 6f 64 65 2d 61 |10:00:00Zknode-a| 00000030: 62 63 31 32 33 6a 32 30 32 36 30 31 31 39 31 30 |bc123j2026011910| ...","title":"Appendix B: Example Segment Hex Dump"},{"location":"RTSL_SPEC/#appendix-c-cli-examples","text":"# Write events to ledger ritma ledger write --event '{\"type\":\"file_access\",...}' # Query by time range ritma ledger query --from 2026-01-19T10:00:00Z --to 2026-01-19T11:00:00Z # Get inclusion proof ritma ledger prove --loc 2026011910:00:4096:512 # Verify entire ledger ritma ledger verify --path ./ledger # Export for court ritma ledger export --loc 2026011910:00:4096:512 --format court-package End of RTSL Specification v1.0","title":"Appendix C: CLI Examples"},{"location":"SDK/","text":"Ritma SDK - Developer Guide Build forensic security applications on top of Ritma's court-grade evidence platform. Installation Option 1: Debian Package (apt) # Add Ritma repository curl -fsSL https://get.ritma.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/ritma.gpg echo \"deb [signed-by=/usr/share/keyrings/ritma.gpg] https://apt.ritma.io stable main\" | sudo tee /etc/apt/sources.list.d/ritma.list # Install sudo apt update sudo apt install ritma Option 2: Cargo (from source) # Clone and build git clone https://github.com/ritma-io/ritma cd ritma cargo build --release # Install sudo ./install.sh Option 3: Quick Install Script curl -sSL https://get.ritma.io | sudo bash Quick Start CLI Commands # Capture events for 60 seconds ritma capture --duration 60 --output ./evidence # Verify a proofpack ritma verify ./evidence/proofpack # Export sealed windows ritma export-window --namespace my-app --output ./export # Start interactive demo ritma demo --scenario ransomware Start Sidecar Service sudo systemctl start ritma-sidecar sudo systemctl enable ritma-sidecar # Check status sudo systemctl status ritma-sidecar journalctl -u ritma-sidecar -f SDK: Building on Ritma Rust Crates Add Ritma crates to your Cargo.toml : [dependencies] # Core types and models common_models = { git = \"https://github.com/ritma-io/ritma\", package = \"common_models\" } # Storage and indexing index_db = { git = \"https://github.com/ritma-io/ritma\", package = \"index_db\" } ritma_contract = { git = \"https://github.com/ritma-io/ritma\", package = \"ritma_contract\" } # BAR pipeline (seal and prove) bar_orchestrator = { git = \"https://github.com/ritma-io/ritma\", package = \"bar_orchestrator\" } # Forensic ML forensic_ml = { git = \"https://github.com/ritma-io/ritma\", package = \"forensic_ml\" } # Security interfaces security_interfaces = { git = \"https://github.com/ritma-io/ritma\", package = \"security_interfaces\" } Example: Custom Event Recording use common_models::{TraceEvent, EventPayload, WindowRange}; use index_db::IndexDb; use bar_orchestrator::Orchestrator; use security_interfaces::PipelineOrchestrator; fn main() -> Result<(), Box<dyn std::error::Error>> { // Initialize storage let index = IndexDb::open(\"/var/lib/ritma/index.db\")?; let orchestrator = Orchestrator::new(index.clone())?; // Record a custom event let event = TraceEvent { trace_id: uuid::Uuid::new_v4().to_string(), timestamp_ns: chrono::Utc::now().timestamp_nanos() as u64, namespace_id: \"my-app\".to_string(), event_type: \"custom_audit\".to_string(), payload: EventPayload::Custom { data: serde_json::json!({ \"user_id\": \"user_123\", \"action\": \"login\", \"ip\": \"192.168.1.100\" }) }, ..Default::default() }; index.insert_trace_event_from_model(&event)?; // Seal window (triggers full BAR pipeline) let window = WindowRange { start_ts: chrono::Utc::now().timestamp() - 300, end_ts: chrono::Utc::now().timestamp(), }; let proof = orchestrator.run_window(\"my-app\", &window)?; println!(\"Sealed window: {:?}\", proof.merkle_root); Ok(()) } Example: Forensic ML Analysis use forensic_ml::{ForensicMLEngine, MLNotary}; use common_models::WindowRange; fn analyze_window(namespace: &str, window: &WindowRange) -> Result<(), Box<dyn std::error::Error>> { let engine = ForensicMLEngine::new(); let notary = MLNotary::new(\"my-key-id\"); // Run 4-layer forensic analysis let result = engine.analyze(namespace, window)?; println!(\"Forensic Score: {:.2}\", result.final_score); println!(\"Verdict: {:?}\", result.verdict); println!(\"Explanation: {}\", result.human_explanation); // Notarize the result (cryptographic attestation) let notarized = notary.notarize(&result)?; println!(\"Notary Hash: {}\", notarized.notary_hash); Ok(()) } Example: Using the Demo Lab use ritma_lab::{LabOrchestrator, ForensicEvidenceCollector}; use std::path::PathBuf; #[tokio::main] async fn main() -> Result<(), Box<dyn std::error::Error>> { // Initialize lab with forensic evidence collection let collector = ForensicEvidenceCollector::new( PathBuf::from(\"./my-lab\"), \"my-node\", \"my-namespace\" )?; collector.start(5).await?; // 5-second windows // Record events for i in 0..100 { let event = create_test_event(i); collector.record_event(event).await?; } // Seal and export collector.seal_window().await?; let path = collector.export_proofpack(\"./output\").await?; println!(\"Exported proofpack to: {}\", path); Ok(()) } Architecture \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Your Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ritma_lab (demo) \u2502 ritma_cli (CLI) \u2502 Your Custom Code \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 bar_orchestrator \u2502 \u2502 (13-stage seal pipeline + RTSL) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 forensic_ml \u2502 snapshotter \u2502 attack_graph \u2502 \u2502 (4-layer ML) \u2502 (capture) \u2502 (threat detection) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 index_db \u2502 \u2502 (SQLite + custody log v2) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ritma_contract \u2502 \u2502 (StorageContract, CAS, RTSL writer) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 common_models \u2502 \u2502 (TraceEvent, WindowPageV2, ProofPack, etc.) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Key Crates Crate Purpose common_models Core types: TraceEvent, WindowRange, ProofPack index_db Event storage, custody log, sealed windows ritma_contract StorageContract, CAS, RTSL output bar_orchestrator 13-stage BAR pipeline forensic_ml 4-layer forensic ML with notarization security_interfaces PipelineOrchestrator trait snapshotter Process tree, socket, container capture attack_graph Threat detection and graph analysis Output Format Proofpack Structure proofpack/ \u251c\u2500\u2500 manifest.json # Bundle metadata \u251c\u2500\u2500 windows/ \u2502 \u2514\u2500\u2500 YYYY/MM/DD/HH/ \u2502 \u251c\u2500\u2500 window_page.cbor # Canonical sealed window \u2502 \u251c\u2500\u2500 window_page.sig.cose # COSE_Sign1 signature \u2502 \u2514\u2500\u2500 leaves.cbor.zst # Event hashes \u251c\u2500\u2500 chain.json # Hash chain continuity \u2514\u2500\u2500 custody_log.jsonl # Audit trail Window Page (CBOR) { \"version\": \"ritma-page@0.2\", \"namespace_id\": \"my-app\", \"window\": { \"start_ts\": 1768893279, \"end_ts\": 1768893579 }, \"merkle_root\": \"abc123...\", \"event_count\": 1500, \"ml_notary_hash\": \"def456...\", \"forensic_verdict\": \"normal\", \"forensic_score\": 0.12, \"prev_hash\": \"789abc...\" } Environment Variables Variable Default Description RITMA_NODE_ID auto Node identifier RITMA_BASE_DIR /var/lib/ritma Base data directory RITMA_OUT_DIR $BASE/out Proofpack output RITMA_OUT_ENABLE 0 Enable RTSL output RITMA_CAS_ENABLE 0 Enable CAS storage RITMA_PRIVACY_MODE full Privacy level RITMA_WINDOW_SECONDS 300 Window duration RITMA_KEY_ID none Signing key ID License Apache 2.0 - See LICENSE","title":"SDK Guide"},{"location":"SDK/#ritma-sdk-developer-guide","text":"Build forensic security applications on top of Ritma's court-grade evidence platform.","title":"Ritma SDK - Developer Guide"},{"location":"SDK/#installation","text":"","title":"Installation"},{"location":"SDK/#option-1-debian-package-apt","text":"# Add Ritma repository curl -fsSL https://get.ritma.io/gpg | sudo gpg --dearmor -o /usr/share/keyrings/ritma.gpg echo \"deb [signed-by=/usr/share/keyrings/ritma.gpg] https://apt.ritma.io stable main\" | sudo tee /etc/apt/sources.list.d/ritma.list # Install sudo apt update sudo apt install ritma","title":"Option 1: Debian Package (apt)"},{"location":"SDK/#option-2-cargo-from-source","text":"# Clone and build git clone https://github.com/ritma-io/ritma cd ritma cargo build --release # Install sudo ./install.sh","title":"Option 2: Cargo (from source)"},{"location":"SDK/#option-3-quick-install-script","text":"curl -sSL https://get.ritma.io | sudo bash","title":"Option 3: Quick Install Script"},{"location":"SDK/#quick-start","text":"","title":"Quick Start"},{"location":"SDK/#cli-commands","text":"# Capture events for 60 seconds ritma capture --duration 60 --output ./evidence # Verify a proofpack ritma verify ./evidence/proofpack # Export sealed windows ritma export-window --namespace my-app --output ./export # Start interactive demo ritma demo --scenario ransomware","title":"CLI Commands"},{"location":"SDK/#start-sidecar-service","text":"sudo systemctl start ritma-sidecar sudo systemctl enable ritma-sidecar # Check status sudo systemctl status ritma-sidecar journalctl -u ritma-sidecar -f","title":"Start Sidecar Service"},{"location":"SDK/#sdk-building-on-ritma","text":"","title":"SDK: Building on Ritma"},{"location":"SDK/#rust-crates","text":"Add Ritma crates to your Cargo.toml : [dependencies] # Core types and models common_models = { git = \"https://github.com/ritma-io/ritma\", package = \"common_models\" } # Storage and indexing index_db = { git = \"https://github.com/ritma-io/ritma\", package = \"index_db\" } ritma_contract = { git = \"https://github.com/ritma-io/ritma\", package = \"ritma_contract\" } # BAR pipeline (seal and prove) bar_orchestrator = { git = \"https://github.com/ritma-io/ritma\", package = \"bar_orchestrator\" } # Forensic ML forensic_ml = { git = \"https://github.com/ritma-io/ritma\", package = \"forensic_ml\" } # Security interfaces security_interfaces = { git = \"https://github.com/ritma-io/ritma\", package = \"security_interfaces\" }","title":"Rust Crates"},{"location":"SDK/#example-custom-event-recording","text":"use common_models::{TraceEvent, EventPayload, WindowRange}; use index_db::IndexDb; use bar_orchestrator::Orchestrator; use security_interfaces::PipelineOrchestrator; fn main() -> Result<(), Box<dyn std::error::Error>> { // Initialize storage let index = IndexDb::open(\"/var/lib/ritma/index.db\")?; let orchestrator = Orchestrator::new(index.clone())?; // Record a custom event let event = TraceEvent { trace_id: uuid::Uuid::new_v4().to_string(), timestamp_ns: chrono::Utc::now().timestamp_nanos() as u64, namespace_id: \"my-app\".to_string(), event_type: \"custom_audit\".to_string(), payload: EventPayload::Custom { data: serde_json::json!({ \"user_id\": \"user_123\", \"action\": \"login\", \"ip\": \"192.168.1.100\" }) }, ..Default::default() }; index.insert_trace_event_from_model(&event)?; // Seal window (triggers full BAR pipeline) let window = WindowRange { start_ts: chrono::Utc::now().timestamp() - 300, end_ts: chrono::Utc::now().timestamp(), }; let proof = orchestrator.run_window(\"my-app\", &window)?; println!(\"Sealed window: {:?}\", proof.merkle_root); Ok(()) }","title":"Example: Custom Event Recording"},{"location":"SDK/#example-forensic-ml-analysis","text":"use forensic_ml::{ForensicMLEngine, MLNotary}; use common_models::WindowRange; fn analyze_window(namespace: &str, window: &WindowRange) -> Result<(), Box<dyn std::error::Error>> { let engine = ForensicMLEngine::new(); let notary = MLNotary::new(\"my-key-id\"); // Run 4-layer forensic analysis let result = engine.analyze(namespace, window)?; println!(\"Forensic Score: {:.2}\", result.final_score); println!(\"Verdict: {:?}\", result.verdict); println!(\"Explanation: {}\", result.human_explanation); // Notarize the result (cryptographic attestation) let notarized = notary.notarize(&result)?; println!(\"Notary Hash: {}\", notarized.notary_hash); Ok(()) }","title":"Example: Forensic ML Analysis"},{"location":"SDK/#example-using-the-demo-lab","text":"use ritma_lab::{LabOrchestrator, ForensicEvidenceCollector}; use std::path::PathBuf; #[tokio::main] async fn main() -> Result<(), Box<dyn std::error::Error>> { // Initialize lab with forensic evidence collection let collector = ForensicEvidenceCollector::new( PathBuf::from(\"./my-lab\"), \"my-node\", \"my-namespace\" )?; collector.start(5).await?; // 5-second windows // Record events for i in 0..100 { let event = create_test_event(i); collector.record_event(event).await?; } // Seal and export collector.seal_window().await?; let path = collector.export_proofpack(\"./output\").await?; println!(\"Exported proofpack to: {}\", path); Ok(()) }","title":"Example: Using the Demo Lab"},{"location":"SDK/#architecture","text":"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 Your Application \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ritma_lab (demo) \u2502 ritma_cli (CLI) \u2502 Your Custom Code \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 bar_orchestrator \u2502 \u2502 (13-stage seal pipeline + RTSL) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 forensic_ml \u2502 snapshotter \u2502 attack_graph \u2502 \u2502 (4-layer ML) \u2502 (capture) \u2502 (threat detection) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 index_db \u2502 \u2502 (SQLite + custody log v2) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 ritma_contract \u2502 \u2502 (StorageContract, CAS, RTSL writer) \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 common_models \u2502 \u2502 (TraceEvent, WindowPageV2, ProofPack, etc.) \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture"},{"location":"SDK/#key-crates","text":"Crate Purpose common_models Core types: TraceEvent, WindowRange, ProofPack index_db Event storage, custody log, sealed windows ritma_contract StorageContract, CAS, RTSL output bar_orchestrator 13-stage BAR pipeline forensic_ml 4-layer forensic ML with notarization security_interfaces PipelineOrchestrator trait snapshotter Process tree, socket, container capture attack_graph Threat detection and graph analysis","title":"Key Crates"},{"location":"SDK/#output-format","text":"","title":"Output Format"},{"location":"SDK/#proofpack-structure","text":"proofpack/ \u251c\u2500\u2500 manifest.json # Bundle metadata \u251c\u2500\u2500 windows/ \u2502 \u2514\u2500\u2500 YYYY/MM/DD/HH/ \u2502 \u251c\u2500\u2500 window_page.cbor # Canonical sealed window \u2502 \u251c\u2500\u2500 window_page.sig.cose # COSE_Sign1 signature \u2502 \u2514\u2500\u2500 leaves.cbor.zst # Event hashes \u251c\u2500\u2500 chain.json # Hash chain continuity \u2514\u2500\u2500 custody_log.jsonl # Audit trail","title":"Proofpack Structure"},{"location":"SDK/#window-page-cbor","text":"{ \"version\": \"ritma-page@0.2\", \"namespace_id\": \"my-app\", \"window\": { \"start_ts\": 1768893279, \"end_ts\": 1768893579 }, \"merkle_root\": \"abc123...\", \"event_count\": 1500, \"ml_notary_hash\": \"def456...\", \"forensic_verdict\": \"normal\", \"forensic_score\": 0.12, \"prev_hash\": \"789abc...\" }","title":"Window Page (CBOR)"},{"location":"SDK/#environment-variables","text":"Variable Default Description RITMA_NODE_ID auto Node identifier RITMA_BASE_DIR /var/lib/ritma Base data directory RITMA_OUT_DIR $BASE/out Proofpack output RITMA_OUT_ENABLE 0 Enable RTSL output RITMA_CAS_ENABLE 0 Enable CAS storage RITMA_PRIVACY_MODE full Privacy level RITMA_WINDOW_SECONDS 300 Window duration RITMA_KEY_ID none Signing key ID","title":"Environment Variables"},{"location":"SDK/#license","text":"Apache 2.0 - See LICENSE","title":"License"},{"location":"production_setup/","text":"Ritma Production Setup (Systemd + Kubernetes + Docker) Goal: a real-world standard setup experience: one config file : ritma.yaml (portable across Python / TypeScript / Rust tooling) one deployment generator : ritma deploy ... (templates) one evidence contract : capture \u2192 seal \u2192 export (ProofPacks) This document is operator-focused and matches the current CLI behavior . 1) The single config file: ritma.yaml 1.1 Minimal example (current) version: \"1.0\" namespace: \"ns://acme/prod/app\" node: id: \"node-001\" labels: environment: \"production\" storage: base_dir: \"/var/lib/ritma\" out_dir: \"/var/lib/ritma/out\" cas_enabled: true capture: window_seconds: 300 privacy_mode: \"full\" # full | redacted | minimal ml: enabled: true threshold: 0.7 deploy: type: \"systemd\" # systemd | kubernetes | docker | standalone Where this is used today: SDKs (Python/TS) can load/validate/generate env files and deployment manifests from ritma.yaml . Runtime binaries ( ritma-sidecar ) currently consume configuration primarily via environment variables and /etc/ritma/ritma.conf . Tip: see schemas/ritma.example.yaml for a complete example. 1.2 Regulated example (suggested pattern) Ritma supports privacy modes at capture time. A common regulated posture is: Default to privacy_mode: redacted or minimal Use short, time-bounded overrides when investigating an active incident (Exact \u201cbreak-glass\u201d workflow enforcement is environment-specific.) 2) Installation 2.1 Debian/Ubuntu (recommended) curl -fsSL https://raw.githubusercontent.com/ritma-io/ritma/main/scripts/setup-apt.sh | sudo bash sudo apt install ritma This installs: ritma (CLI) ritma-sidecar (capture daemon) /etc/ritma/ritma.conf (env config) 2.2 From source (developer) cargo build --release -p ritma_cli -p tracer_sidecar sudo ./install.sh 3) Systemd setup (Linux hosts) 3.1 Configure Edit: /etc/ritma/ritma.conf (environment variables) Minimum recommended values: RITMA_NODE_ID=node-001 RITMA_BASE_DIR=/var/lib/ritma RITMA_OUT_ENABLE=1 RITMA_CAS_ENABLE=1 RUST_LOG=ritma=info 3.2 Start the sidecar sudo systemctl daemon-reload sudo systemctl enable ritma-sidecar sudo systemctl start ritma-sidecar sudo systemctl status ritma-sidecar 3.3 Verify capture is working The sidecar writes to IndexDB. You can sanity-check with: ritma doctor --index-db /var/lib/ritma/index_db.sqlite --namespace ns://acme/prod/app 4) Docker setup (compose) 4.1 Generate templates ritma deploy export --out ./deploy-out --namespace ns://acme/prod/app Expected output is a set of deploy templates under ./deploy-out/ . 4.2 Run ritma up --help ritma ps --help ritma logs --help 4.3 Stop ritma down --help 5) Kubernetes setup 5.1 Generate manifests ritma deploy k8s --dir ./deploy-out/k8s --namespace ns://acme/prod/app Expected output is a set of Kubernetes YAML templates under ./deploy-out/k8s/ . 5.2 Apply kubectl apply -f ./deploy-out/k8s/ 5.3 Observe kubectl get pods -A | grep ritma kubectl logs -A -l app=ritma-sidecar --tail=200 5.4 Verify it\u2019s capturing Use ritma doctor against the IndexDB path you mounted: ritma doctor --index-db /data/index_db.sqlite --namespace ns://acme/prod/app 6) Production operations (day-2) 6.1 Seal a window (strict / production) ritma seal-window --namespace <ns> --start <unix_seconds> --end <unix_seconds> --strict Notes: --strict fails if the window has zero trace events. --demo-mode exists for testing, but production should prefer the strict path. 6.2 Export proof (ProofPack v2) ritma export window --namespace <ns> --start <start> --end <end> --out ./proofpacks/window ritma verify-proof --path ./proofpacks/window 6.3 Diff (human-readable) ritma diff --a <ml_id_baseline> --b <ml_id_incident> 7) Notes on current vs. planned UX The CLI already provides deploy template generation ( ritma deploy export|systemd|k8s ). Planned improvements (explicitly not all wired everywhere yet): ritma deploy export consumes ritma.yaml directly (single source of truth) ritma deploy validate performs host readiness checks (paths, permissions, kernel capability) Signed ProofPacks by default when a node keystore is configured","title":"Production Setup"},{"location":"production_setup/#ritma-production-setup-systemd-kubernetes-docker","text":"Goal: a real-world standard setup experience: one config file : ritma.yaml (portable across Python / TypeScript / Rust tooling) one deployment generator : ritma deploy ... (templates) one evidence contract : capture \u2192 seal \u2192 export (ProofPacks) This document is operator-focused and matches the current CLI behavior .","title":"Ritma Production Setup (Systemd + Kubernetes + Docker)"},{"location":"production_setup/#1-the-single-config-file-ritmayaml","text":"","title":"1) The single config file: ritma.yaml"},{"location":"production_setup/#11-minimal-example-current","text":"version: \"1.0\" namespace: \"ns://acme/prod/app\" node: id: \"node-001\" labels: environment: \"production\" storage: base_dir: \"/var/lib/ritma\" out_dir: \"/var/lib/ritma/out\" cas_enabled: true capture: window_seconds: 300 privacy_mode: \"full\" # full | redacted | minimal ml: enabled: true threshold: 0.7 deploy: type: \"systemd\" # systemd | kubernetes | docker | standalone Where this is used today: SDKs (Python/TS) can load/validate/generate env files and deployment manifests from ritma.yaml . Runtime binaries ( ritma-sidecar ) currently consume configuration primarily via environment variables and /etc/ritma/ritma.conf . Tip: see schemas/ritma.example.yaml for a complete example.","title":"1.1 Minimal example (current)"},{"location":"production_setup/#12-regulated-example-suggested-pattern","text":"Ritma supports privacy modes at capture time. A common regulated posture is: Default to privacy_mode: redacted or minimal Use short, time-bounded overrides when investigating an active incident (Exact \u201cbreak-glass\u201d workflow enforcement is environment-specific.)","title":"1.2 Regulated example (suggested pattern)"},{"location":"production_setup/#2-installation","text":"","title":"2) Installation"},{"location":"production_setup/#21-debianubuntu-recommended","text":"curl -fsSL https://raw.githubusercontent.com/ritma-io/ritma/main/scripts/setup-apt.sh | sudo bash sudo apt install ritma This installs: ritma (CLI) ritma-sidecar (capture daemon) /etc/ritma/ritma.conf (env config)","title":"2.1 Debian/Ubuntu (recommended)"},{"location":"production_setup/#22-from-source-developer","text":"cargo build --release -p ritma_cli -p tracer_sidecar sudo ./install.sh","title":"2.2 From source (developer)"},{"location":"production_setup/#3-systemd-setup-linux-hosts","text":"","title":"3) Systemd setup (Linux hosts)"},{"location":"production_setup/#31-configure","text":"Edit: /etc/ritma/ritma.conf (environment variables) Minimum recommended values: RITMA_NODE_ID=node-001 RITMA_BASE_DIR=/var/lib/ritma RITMA_OUT_ENABLE=1 RITMA_CAS_ENABLE=1 RUST_LOG=ritma=info","title":"3.1 Configure"},{"location":"production_setup/#32-start-the-sidecar","text":"sudo systemctl daemon-reload sudo systemctl enable ritma-sidecar sudo systemctl start ritma-sidecar sudo systemctl status ritma-sidecar","title":"3.2 Start the sidecar"},{"location":"production_setup/#33-verify-capture-is-working","text":"The sidecar writes to IndexDB. You can sanity-check with: ritma doctor --index-db /var/lib/ritma/index_db.sqlite --namespace ns://acme/prod/app","title":"3.3 Verify capture is working"},{"location":"production_setup/#4-docker-setup-compose","text":"","title":"4) Docker setup (compose)"},{"location":"production_setup/#41-generate-templates","text":"ritma deploy export --out ./deploy-out --namespace ns://acme/prod/app Expected output is a set of deploy templates under ./deploy-out/ .","title":"4.1 Generate templates"},{"location":"production_setup/#42-run","text":"ritma up --help ritma ps --help ritma logs --help","title":"4.2 Run"},{"location":"production_setup/#43-stop","text":"ritma down --help","title":"4.3 Stop"},{"location":"production_setup/#5-kubernetes-setup","text":"","title":"5) Kubernetes setup"},{"location":"production_setup/#51-generate-manifests","text":"ritma deploy k8s --dir ./deploy-out/k8s --namespace ns://acme/prod/app Expected output is a set of Kubernetes YAML templates under ./deploy-out/k8s/ .","title":"5.1 Generate manifests"},{"location":"production_setup/#52-apply","text":"kubectl apply -f ./deploy-out/k8s/","title":"5.2 Apply"},{"location":"production_setup/#53-observe","text":"kubectl get pods -A | grep ritma kubectl logs -A -l app=ritma-sidecar --tail=200","title":"5.3 Observe"},{"location":"production_setup/#54-verify-its-capturing","text":"Use ritma doctor against the IndexDB path you mounted: ritma doctor --index-db /data/index_db.sqlite --namespace ns://acme/prod/app","title":"5.4 Verify it\u2019s capturing"},{"location":"production_setup/#6-production-operations-day-2","text":"","title":"6) Production operations (day-2)"},{"location":"production_setup/#61-seal-a-window-strict-production","text":"ritma seal-window --namespace <ns> --start <unix_seconds> --end <unix_seconds> --strict Notes: --strict fails if the window has zero trace events. --demo-mode exists for testing, but production should prefer the strict path.","title":"6.1 Seal a window (strict / production)"},{"location":"production_setup/#62-export-proof-proofpack-v2","text":"ritma export window --namespace <ns> --start <start> --end <end> --out ./proofpacks/window ritma verify-proof --path ./proofpacks/window","title":"6.2 Export proof (ProofPack v2)"},{"location":"production_setup/#63-diff-human-readable","text":"ritma diff --a <ml_id_baseline> --b <ml_id_incident>","title":"6.3 Diff (human-readable)"},{"location":"production_setup/#7-notes-on-current-vs-planned-ux","text":"The CLI already provides deploy template generation ( ritma deploy export|systemd|k8s ). Planned improvements (explicitly not all wired everywhere yet): ritma deploy export consumes ritma.yaml directly (single source of truth) ritma deploy validate performs host readiness checks (paths, permissions, kernel capability) Signed ProofPacks by default when a node keystore is configured","title":"7) Notes on current vs. planned UX"},{"location":"ritma_transparency_forensics/","text":"Ritma Transparency Log + Forensics \u201cOne\u2011Minute Page\u201d (Industry-Standard Design) Status Draft. Goal Define an industry-standard , tamper-evident , operator-friendly architecture for Ritma such that for each namespace and each 60s window you can produce a single forensic \u201cpage\u201d that: Reflects exactly what the sensor recorded (the window\u2019s TraceEvent s) Includes BAR outputs (features, graph, ML, verdict, snapshot manifest) Is sealed into an append-only transparency ledger (RTSL) Can be exported into a portable proofpack (human-usable forensic bundle) Supports retention/pruning of hot storage without losing auditability Scope Linux runtime capture ( tracer_sidecar ) Storage ( index_db.sqlite ) as hot/cold path Window processing and sealing ( bar_orchestrator + ritma_contract ) Ledger format ( RTSL ) Export + verification UX ( ritma_cli ) Not covered here: multi-tenant SaaS control plane, remote transparency gossip network, legal admissibility procedures beyond technical chain-of-custody. Industry standards to emulate (short list) 1) Certificate Transparency (CT): append-only Merkle logs + signed tree heads CT defines a Merkle tree with domain separation for leaf vs node hashing, and uses Signed Tree Heads (STHs) and consistency proofs to detect equivocation. Merkle tree + domain separation (leaf uses HASH(0x00 || leaf) ; node uses HASH(0x01 || left || right) ) \u2014 RFC 9162 \u00a72.1.1 https://www.rfc-editor.org/rfc/rfc9162.html Signed Tree Head (STH) (tree_size, root_hash, timestamp, signature) + consistency proof structure \u2014 RFC 9162 \u00a74.9\u20134.11 Why it matters for Ritma: - RTSL is effectively a local transparency log for window commitments. - \u201cHour roots / chain roots\u201d are analogous to CT tree heads. 2) Trillian: leaf hashing vs identity hash + store big blobs outside the log Trillian guidance separates: - Merkle hash : what is committed into the transparency log - Identity hash : optional dedupe semantics It also recommends storing large/private blobs outside the transparency log and logging only hashes. Leaf hashing and separate identity hash \u2014 Trillian \u201cTransparent Logging: A Guide\u201d https://raw.githubusercontent.com/google/trillian/master/docs/TransparentLogging.md Why it matters for Ritma: - Don\u2019t stuff raw TraceEvent s inside RTSL; store them in a content-addressed evidence store (or DB) and commit only canonical hashes. 3) Sigstore Rekor: operational transparency log + size limits + sharding Rekor is a transparency log for signed metadata and highlights operational constraints (e.g., entry size limits, sharding). Rekor v1 public instance + API endpoints + size limits \u2014 Rekor README https://raw.githubusercontent.com/sigstore/rekor/main/README.md Why it matters for Ritma: - Proofpacks / \u201cpages\u201d must remain reasonably sized; large artifacts should be referenced by hash. 4) CBOR deterministic encoding Deterministic encodings are a standard technique to ensure canonical hashes are stable across implementations. Deterministic CBOR encoding requirements \u2014 RFC 8949 \u00a74.2 https://www.rfc-editor.org/rfc/rfc8949.html Why it matters for Ritma: - canonical_leaf_hash() must be based on deterministic encoding. - Proofpacks should use canonical encoding to keep hashes stable. 5) COSE signing COSE provides standard signed container formats for CBOR payloads. COSE signing structures \u2014 RFC 9052 \u00a74 https://www.rfc-editor.org/rfc/rfc9052.html Why it matters for Ritma: - RTSL signatures and proofpack signatures should follow consistent signing semantics. 6) SCITT: signed statements + receipts + transparency service model SCITT defines a general model for signed statements registered with a transparency service, producing receipts that can be audited. SCITT architecture overview \u2014 draft-ietf-scitt-architecture \u00a75 https://datatracker.ietf.org/doc/html/draft-ietf-scitt-architecture Why it matters for Ritma: - A \u201cone-minute page\u201d can be treated as a signed statement (about a window) with a receipt (RTSL inclusion/consistency material). 7) NIST chain-of-custody definition For forensic credibility, maintain chain-of-custody metadata. NIST definition (CSRC glossary) https://csrc.nist.gov/glossary/term/chain_of_custody Why it matters for Ritma: - Proofpacks should include who/what produced the page, when, and under what configuration. Ritma design principles (derived from standards) A) Transparency log stores commitments , not full data RTSL should store: time window boundaries tree_size / counts Merkle root of canonical leaf hashes linkage to previous heads (hour root / chain root) signatures B) Evidence/artifacts are content-addressed and referenced by hash Keep large/private artifacts in: RITMA_OUT/cases/<case_id>/... (or another CAS) or a DB/object store RTSL commits hashes. C) Deterministic canonicalization everywhere Leaf hash canonical tuple (already in bar_orchestrator::canonical_leaf_hash ) Canonical CBOR for proofpack files D) Simple responder UX A responder should be able to do: Seal continuously Export one window (by time range) into a \u201cpage/proofpack\u201d directory Verify proofpack against RTSL (and optionally against remote witness) Target \u201cOne\u2011Minute Page\u201d model What the page contains For a window [start,end] and namespace ns : Trace excerpt (sensor truth) list of TraceEvent s in the window possibly redacted (hash-only mode) BAR derived outputs window features summary attack graph edges + graph hash ML score + explanation verdict + reasons Evidence pack manifest list of artifact blobs with sha256 (or stronger hash) privacy redactions Ledger receipt RTSL record reference (segment id / hour root / chain root) signatures (future) inclusion/consistency proofs Chain-of-custody metadata node_id, sensor version, config hash, signer id Where each part lives Hot path : index_db.sqlite (queryable, pruneable) Transparency ledger : RTSL ( RITMA_OUT/ledger/v2/... ) commits roots Evidence store : proofpack/case directory containing files, referenced by hash This mirrors Trillian guidance: log the hash; store large data separately. Mapping to current Ritma code Capture crates/tracer_sidecar produces common_models::TraceEvent Inserts into IndexDb::insert_trace_event_from_model() Window processing + sealing crates/bar_orchestrator::Orchestrator::run_window() Correlate window (features + attack graph) Run ML Judge Snapshot (optional) Seal (proof metadata + receipts) Write RITMA_OUT via StorageContract::write_window_output() Ledger output format crates/ritma_contract::StorageContract::write_window_output() RITMA_OUT_FORMAT=legacy|rtsl|dual RITMA_OUT_ENFORCE_RTSL=1 forces RTSL Proofpack export crates/ritma_cli has export functions that read IndexDB (events/features/ml/etc.) and write canonical CBOR files. Known gaps (what must change) 1) Snapshot must include the real trace excerpt Bug fixed : bar_orchestrator previously called snapshotter with &[] . It must pass the actual trace_events excerpt for [start,end] . 2) Snapshotter returns only hashes/metadata, not persisted artifacts Today snapshotter computes artifact hashes but does not write the artifact payloads into an evidence store. Industry standard practice is: - write artifacts to a content-addressed store - log the hashes + metadata in the manifest 3) Export should not require ML id UX should allow: - ritma export-window --namespace ... --start ... --end ... producing one proofpack 4) RTSL-only should be the default for production If RTSL is the standard, deployments should enforce it (and optionally disallow legacy output). 5) Retention should be explicit and safe Pruning trace_events must happen only after: - RTSL record exists - proofpack/evidence is exported or copied to long-term storage Recommended implementation plan (in repo) Phase 1 (correctness) Ensure bar_orchestrator passes real per-window trace_excerpt to snapshotter. Enforce RTSL-only in production configurations. Phase 2 (forensic usability) Add a window export command that generates the \u201cone-minute page\u201d proofpack directly from (namespace,start,end) . Include the trace excerpt file in the proofpack (canonical CBOR). Phase 3 (evidence store) Implement snapshot artifact persistence to an evidence store (e.g., RITMA_OUT/cases/<case_id>/... ). Proofpack references should be hash-addressed. Phase 4 (transparency hardening) Add verifiable inclusion/consistency proof material for RTSL (CT-like proofs). Add witness/gossip support (future). Environment recommendations For production-grade \u201cRTSL standard\u201d deployments: RITMA_OUT_ENABLE=1 RITMA_OUT_FORMAT=rtsl RITMA_OUT_ENFORCE_RTSL=1 Success criteria Given a window [start,end] , exported proofpack contains: trace_events.cbor (what sidecar recorded) attack_graph.cbor , coverage.cbor , ml_score , verdict manifest.cbor Verification confirms: proofpack hashes match IndexDB records merkle root matches RTSL record for that window Chain-of-Custody (CoC) \u2014 Industry-Standard Requirements This section defines Ritma's chain-of-custody architecture for military , critical infrastructure , financial , and court-admissible forensic contexts. It draws from: ACPO/NPCC Good Practice Guide (UK digital evidence principles) ISO/IEC 27037:2012 \u2014 identification, collection, acquisition, preservation of digital evidence ISO/IEC 27041:2015 \u2014 assuring suitability of investigative methods ISO/IEC 27042:2015 \u2014 analysis and interpretation of digital evidence ISO/IEC 27043:2015 \u2014 incident investigation principles and processes NIST SP 800-86 \u2014 integrating forensic techniques into incident response NISTIR 8387 \u2014 digital evidence preservation for evidence handlers NIST SP 800-88 Rev.1 \u2014 media sanitization (secure deletion) RFC 3161 \u2014 Time-Stamp Protocol (TSP) for evidence timestamping IETF COSE Merkle Tree Proofs (draft-ietf-cose-merkle-tree-proofs) \u2014 receipts for transparency logs CoC Principle 1: No action should change evidence Standard : ACPO Principle 1 / ISO 27037 \u00a77.1.1 Ritma implementation : - tracer_sidecar captures events in append-only mode; no modification of raw events after insertion. - index_db uses hash chaining ( event_hash , prev_hash ) so any tampering breaks the chain. - RTSL commits Merkle roots of sealed windows; once sealed, the window's hash is immutable. CoC Principle 2: Competent persons access evidence with audit trail Standard : ACPO Principle 2 / ISO 27037 \u00a77.1.2 / UK MoJ POL.POP.009\u2013011 Ritma implementation : - Every custody-relevant action is logged to a custody_log table: - CAPTURE \u2014 sidecar inserted events - SEAL \u2014 bar_orchestrator sealed window into RTSL - EXPORT \u2014 proofpack exported - PRUNE \u2014 hot data deleted after seal - VERIFY \u2014 proofpack verified - Each log entry includes: - timestamp (RFC 3339, ideally RFC 3161 TSA-signed) - actor_id (node_id / user / service principal) - action - target (namespace, window_id, artifact hash) - prev_log_hash (hash chain for tamper detection) - signature (optional, for high-assurance deployments) CoC Principle 3: Audit trail enables third-party replication Standard : ACPO Principle 3 / ISO 27043 \u00a76.3 / UK MoJ POL.POP.009 Ritma implementation : - Proofpacks include: - custody_log.cbor \u2014 excerpt of custody events for that window - manifest.cbor \u2014 artifact hashes + metadata - rtsl_receipt.cbor \u2014 RTSL inclusion proof (Merkle path + signed tree head) - A third party can: 1. Verify trace_events.cbor hash matches manifest 2. Verify manifest hash matches RTSL leaf 3. Verify RTSL inclusion proof against signed tree head 4. Verify custody_log hash chain is unbroken CoC Principle 4: Investigation leader ensures legal compliance Standard : ACPO Principle 4 / ISO 27041 / UK MoJ POL.POP.014 Ritma implementation : - Ritma provides technical controls ; legal/procedural compliance is the operator's responsibility. - Configuration options: - RITMA_COC_REQUIRE_SIGNATURE=1 \u2014 require cryptographic signature on custody log entries - RITMA_COC_TSA_URL=... \u2014 RFC 3161 Time-Stamp Authority for external timestamping - RITMA_COC_RETENTION_DAYS=... \u2014 minimum retention before pruning allowed Secure Deletion After Sealing \u2014 Tamper-Evident Pruning Problem Storing all raw TraceEvent s indefinitely is impractical for high-volume deployments. However, deleting evidence without proper controls could: 1. Destroy forensic value before it's needed 2. Enable cover-ups by malicious insiders 3. Violate retention regulations (PIPEDA 2yr, Qu\u00e9bec Law 25 5yr, etc.) Industry guidance NIST SP 800-88 Rev.1 : Sanitization must be verified and documented . Cryptographic erasure (deleting keys) is acceptable if keys are irreversibly destroyed. ISO 27037 \u00a77.4 : Preservation includes documenting any changes to evidence, including destruction. UK MoJ POL.POP.013 : Forensic Readiness Plan must include secure disposal procedures. Ritma secure deletion policy Rule : Raw data in index_db may be pruned only after : 1. The window is sealed into RTSL (Merkle root committed) 2. A custody_log entry of type PRUNE is recorded with: - window boundaries - count of events deleted - hash of deleted data (for audit) - reference to RTSL seal record 3. (Optional) Proofpack has been exported to long-term storage Implementation : index_db.prune_sealed_window(namespace, window_id) -> PruneResult 1. Verify window_id exists in RTSL (sealed) 2. Compute hash of events to be deleted 3. Insert custody_log entry (action=PRUNE, target=window_id, data_hash=...) 4. DELETE FROM trace_events WHERE namespace=? AND ts >= start AND ts <= end 5. Return PruneResult { events_deleted, custody_log_id } Guardrails : - RITMA_PRUNE_REQUIRE_SEAL=1 (default) \u2014 prune fails if window not sealed - RITMA_PRUNE_REQUIRE_EXPORT=1 \u2014 prune fails if proofpack not exported - RITMA_PRUNE_MIN_AGE_HOURS=24 \u2014 minimum age before pruning allowed Exploitation prevention Attack vector Mitigation Attacker deletes events before seal prune_sealed_window checks RTSL seal exists; fails otherwise Attacker modifies custody_log custody_log uses hash chaining; any gap/modification detectable Attacker replays old seal to justify deletion RTSL seal includes timestamp; prune checks seal_ts < prune_ts Attacker with DB access deletes directly custody_log is append-only; missing entries detectable by hash chain gaps Attacker deletes custody_log custody_log can be replicated to external witness / SIEM; gaps detectable Cryptographic erasure (future) For deployments requiring NIST 800-88 \"Purge\" level: - Encrypt trace_events with per-window key - Store key in HSM or secure enclave - Pruning = delete key (cryptographic erasure) - Custody_log records key deletion event Custody Log Schema CREATE TABLE IF NOT EXISTS custody_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT NOT NULL, -- RFC 3339 timestamp actor_id TEXT NOT NULL, -- node_id / user / service action TEXT NOT NULL, -- CAPTURE|SEAL|EXPORT|PRUNE|VERIFY|ACCESS namespace_id TEXT, window_id TEXT, target_hash TEXT, -- hash of affected data details TEXT, -- JSON metadata prev_log_hash TEXT, -- hash chain log_hash TEXT NOT NULL, -- hash of this entry signature TEXT, -- optional cryptographic signature tsa_token BLOB -- optional RFC 3161 timestamp token ); CREATE INDEX IF NOT EXISTS idx_custody_log_ns_ts ON custody_log(namespace_id, ts); CREATE INDEX IF NOT EXISTS idx_custody_log_action ON custody_log(action); RFC 3161 Timestamping (Optional) For court-admissible evidence, external timestamping proves evidence existed at a specific time: Compute hash of sealed window (or custody_log entry) Send TimeStampReq to TSA (e.g., FreeTSA, DigiCert, Entrust) Receive TimeStampResp containing signed timestamp token Store token in custody_log.tsa_token or proofpack Configuration : - RITMA_TSA_URL=https://freetsa.org/tsr (example) - RITMA_TSA_HASH_ALG=SHA-256 COSE Receipts for RTSL (Future) IETF draft-ietf-cose-merkle-tree-proofs defines CBOR-encoded receipts for transparency logs: Inclusion proof : proves a leaf is in the Merkle tree Consistency proof : proves tree grew append-only Ritma can adopt this format for rtsl_receipt.cbor : { \"vds\": 1, // RFC9162_SHA256 \"tree_size\": 12345, \"root\": h'...', // 32-byte root hash \"leaf_index\": 42, \"inclusion_path\": [h'...', h'...', ...], \"signature\": h'...' // COSE_Sign1 } Summary: Ritma CoC Compliance Matrix Requirement Standard Ritma Feature Append-only evidence capture ISO 27037, ACPO P1 hash-chained trace_events Tamper-evident ledger CT, SCITT RTSL Merkle tree + signed roots Audit trail for all actions ACPO P2-3, ISO 27043 custody_log table Secure deletion with proof NIST 800-88, ISO 27037 prune_sealed_window + custody_log External timestamping RFC 3161 TSA integration (optional) Portable evidence bundle ISO 27042 proofpack export Third-party verification ACPO P3 inclusion proofs + hash verification --- Ritma v2 Forensic Page Standard (Normative Specification) Status : Draft Normative Version : 2.0 Applies to : RTSL, Proofpack, CAS, Custody Log This section defines the exact bytes-on-disk , exact hashes/signatures , and exact file names for Ritma forensic evidence. Implementations MUST NOT deviate from this specification. 1. Window Page: The Canonical Signed Statement 1.1 window_page.cbor \u2014 The SCITT-like Statement The window page is the single canonical object that everything else references. It is a signed statement (SCITT-shaped) that commits to all evidence for a one-minute window. Encoding : Deterministic CBOR (RFC 8949 \u00a74.2) Map key ordering : Lexicographic by UTF-8 bytes Integer encoding : Minimal bytes Float encoding : Shortest form preserving value 1.1.1 Canonical CBOR Map Structure { \"v\": 2, ; page format version (integer) \"ns\": \"<namespace_id>\", ; namespace URI (tstr) \"win\": { ; window boundaries \"id\": \"<window_id>\", ; UUID (tstr) \"start\": \"<RFC3339>\", ; window start (tstr) \"end\": \"<RFC3339>\" ; window end (tstr) }, \"sensor\": { ; sensor identity \"node_id\": \"<RITMA_NODE_ID>\", ; node identifier (tstr) \"tracer_ver\": \"<semver>\", ; tracer_sidecar version (tstr) \"bar_ver\": \"<semver>\" ; bar_orchestrator version (tstr) }, \"cfg\": { ; configuration hashes \"config_hash\": \"<sha256>\", ; effective config hash (tstr) \"policy_hash\": \"<sha256>\" ; policy pack hash (tstr) }, \"counts\": { ; event counts (for quick triage) \"events\": <uint>, ; trace_events count \"edges\": <uint>, ; attack_graph edges count \"artifacts\": <uint> ; evidence artifacts count }, \"trace\": { ; trace evidence commitment \"mode\": \"full\" | \"hash_only\", ; privacy mode (tstr) \"trace_cbor_hash\": \"<sha256>\", ; SHA-256 of trace_events.cbor (tstr) \"trace_chain_head\": \"<sha256>\" ; last event_hash in window (tstr, optional) }, \"bar\": { ; BAR outputs commitment \"features_hash\": \"<sha256>\", ; SHA-256 of features.cbor (tstr) \"graph_hash\": \"<sha256>\", ; SHA-256 of attack_graph.cbor (tstr) \"ml_hash\": \"<sha256>\", ; SHA-256 of ml_result.cbor (tstr) \"verdict_hash\": \"<sha256>\" ; SHA-256 of verdict.cbor (tstr) }, \"manifest_hash\": \"<sha256>\", ; SHA-256 of manifest.cbor (tstr) \"custody_log_hash\": \"<sha256>\", ; SHA-256 of custody_log.cbor (tstr) \"rtsl\": { ; RTSL commitment \"leaf_hash\": \"<sha256>\", ; CT-style leaf hash (tstr) \"leaf_index\": <uint>, ; position in log (uint, optional) \"sth_ref\": \"<sha256>\" ; STH hash reference (tstr) }, \"time\": { ; timestamps \"sealed_ts\": \"<RFC3339>\", ; seal timestamp (tstr) \"tsa_token_hash\": \"<sha256>\" ; RFC 3161 token hash (tstr, optional) } } 1.1.2 Hash Computation All hashes in this spec are SHA-256 unless otherwise noted. hash(x) = SHA-256(x) For files: file_hash = SHA-256(file_bytes) 1.2 window_page.sig.cose \u2014 COSE_Sign1 Signature The page MUST be signed using COSE_Sign1 (RFC 9052 \u00a74.2). Algorithm : ES256 (ECDSA w/ SHA-256 on P-256) or EdDSA (Ed25519) Protected header : { 1: -7, ; alg: ES256 (or -8 for EdDSA) 3: \"application/ritma-page+cbor\" ; content type } Payload : The exact bytes of window_page.cbor External AAD : Empty COSE_Sign1 = [ protected: << { 1: -7, 3: \"application/ritma-page+cbor\" } >>, unprotected: {}, payload: << window_page.cbor bytes >>, signature: << 64 bytes for ES256 >> ] 2. RTSL Leaf Definition (Hard Rule) 2.1 Leaf Payload RTSL commits to the page hash , not raw events. The leaf payload is a minimal routing envelope: { \"v\": 2, ; RTSL version \"ns\": \"<namespace_id>\", ; namespace \"win_id\": \"<window_id>\", ; window UUID \"start\": <unix_ts>, ; window start (integer seconds) \"end\": <unix_ts>, ; window end (integer seconds) \"page_hash\": \"<sha256>\" ; SHA-256 of window_page.cbor } Canonical encoding : Deterministic CBOR, keys sorted lexicographically. 2.2 Leaf Hash (CT-style Domain Separation) leaf_payload_bytes = canonical_cbor(leaf_payload) leaf_hash = SHA-256(0x00 || leaf_payload_bytes) The 0x00 prefix is the leaf domain separator per RFC 9162 \u00a72.1. 2.3 Node Hash (Merkle Tree Interior) node_hash = SHA-256(0x01 || left_hash || right_hash) The 0x01 prefix is the node domain separator . 2.4 Signed Tree Head (STH) { \"v\": 2, ; STH version \"log_id\": \"<sha256>\", ; log identity (hash of log public key) \"tree_size\": <uint>, ; number of leaves \"root_hash\": \"<sha256>\", ; Merkle root \"timestamp\": \"<RFC3339>\", ; STH timestamp \"signature\": \"<base64>\" ; COSE_Sign1 detached signature } The STH MUST be signed with the log's signing key (same algorithm as page signatures). 3. Proofpack Directory Layout (Exact, Boring, Predictable) When exporting a window: ritma export-window --ns <ns> --start <RFC3339> --end <RFC3339> Output directory structure: proofpack_<ns_safe>_<start_ts>_<end_ts>/ \u251c\u2500\u2500 README.txt # Human one-screen summary \u251c\u2500\u2500 window_page.cbor # The canonical signed statement \u251c\u2500\u2500 window_page.sig.cose # COSE_Sign1 signature \u2502 \u251c\u2500\u2500 trace_events.cbor # Optional (omit if hash_only mode) \u251c\u2500\u2500 attack_graph.cbor # Attack graph edges \u251c\u2500\u2500 features.cbor # Window features \u251c\u2500\u2500 ml_result.cbor # ML score + explanation \u251c\u2500\u2500 verdict.cbor # Verdict + reasons \u2502 \u251c\u2500\u2500 manifest.cbor # Artifact manifest with hashes \u251c\u2500\u2500 custody_log.cbor # Custody log excerpt for this window \u2502 \u251c\u2500\u2500 rtsl_receipt.cbor # STH + inclusion proof \u251c\u2500\u2500 keyring/ \u2502 \u2514\u2500\u2500 signer_pub.cosekey # Public key for signature verification \u2502 \u2514\u2500\u2500 hashes.txt # Human-friendly digest list (optional) 3.1 File Naming Convention <ns_safe> : namespace with / replaced by _ , max 64 chars <start_ts> , <end_ts> : Unix timestamp (integer seconds) Example: proofpack_ns___test_prod_app_svc_1737331200_1737331260/ 3.2 README.txt Format Ritma Forensic Proofpack v2 =========================== Namespace: ns://test/prod/app/svc Window: 2025-01-19T12:00:00Z to 2025-01-19T12:01:00Z Window ID: a1b2c3d4-e5f6-7890-abcd-ef1234567890 Node: demo-node Sealed: 2025-01-19T12:01:05Z Counts: Events: 142 Edges: 23 Artifacts: 5 Verification: ritma verify-proofpack . Page Hash: sha256:abc123... RTSL Leaf: #42 in log STH Root: sha256:def456... 3.3 manifest.cbor Structure { \"v\": 2, \"artifacts\": [ { \"name\": \"trace_events.cbor\", \"sha256\": \"<hash>\", \"size\": <bytes>, \"cas_ref\": \"sha256/<aa>/<bb>/<hash>\" ; optional CAS path }, ... ], \"privacy\": { \"mode\": \"full\" | \"hash_only\", \"redactions\": [\"pii\", \"secrets\"] } } 3.4 rtsl_receipt.cbor Structure { \"v\": 2, \"leaf_index\": <uint>, \"leaf_hash\": \"<sha256>\", \"inclusion_path\": [ { \"side\": \"L\" | \"R\", \"hash\": \"<sha256>\" }, ... ], \"sth\": { \"tree_size\": <uint>, \"root_hash\": \"<sha256>\", \"timestamp\": \"<RFC3339>\", \"log_id\": \"<sha256>\", \"signature\": \"<base64>\" } } 4. Content-Addressed Store (CAS) 4.1 Filesystem CAS Layout RITMA_OUT/cas/sha256/<aa>/<bb>/<full_hash> Where: - <aa> = first 2 hex chars of hash - <bb> = next 2 hex chars - <full_hash> = full 64-char hex SHA-256 Example: RITMA_OUT/cas/sha256/ab/cd/abcd1234567890... 4.2 CAS Operations Store : fn cas_store(data: &[u8]) -> String { let hash = sha256(data); let path = format!(\"cas/sha256/{}/{}/{}\", &hash[0..2], &hash[2..4], hash); write_if_not_exists(path, data); hash } Retrieve : fn cas_get(hash: &str) -> Option<Vec<u8>> { let path = format!(\"cas/sha256/{}/{}/{}\", &hash[0..2], &hash[2..4], hash); read_file(path).ok() } 4.3 Proofpack Export Modes Mode Behavior full Include all artifact payloads in proofpack hash_only Include only hashes; payloads stay in CAS hybrid Include small artifacts (<1MB); hash large ones 5. Custody Log v2 (Court/Audit Friendly) 5.1 Enhanced Schema CREATE TABLE IF NOT EXISTS custody_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT NOT NULL, -- RFC 3339 timestamp actor_id TEXT NOT NULL, -- node_id / user / service session_id TEXT, -- ties actions within process lifetime tool TEXT NOT NULL, -- tracer_sidecar | bar_orchestrator | ritma_cli action TEXT NOT NULL, -- CAPTURE|SEAL|EXPORT|PRUNE|VERIFY|ACCESS namespace_id TEXT, window_id TEXT, target_hash TEXT, -- hash of affected data details BLOB, -- CBOR (not JSON) for canonicalization prev_log_hash TEXT, -- hash chain log_hash TEXT NOT NULL, -- hash of this entry signature TEXT, -- optional cryptographic signature tsa_token BLOB, -- optional RFC 3161 timestamp token host_attestation TEXT -- optional TPM/IMA hash ); 5.2 Custody Log Entry Hash entry_bytes = canonical_cbor({ ts, actor_id, session_id, tool, action, namespace_id, window_id, target_hash, details_hash, prev_log_hash }) log_hash = SHA-256(entry_bytes) 5.3 custody_log.cbor Export Format { \"v\": 2, \"entries\": [ { \"ts\": \"<RFC3339>\", \"actor_id\": \"<id>\", \"session_id\": \"<uuid>\", \"tool\": \"bar_orchestrator\", \"action\": \"SEAL\", \"namespace_id\": \"<ns>\", \"window_id\": \"<win_id>\", \"target_hash\": \"<sha256>\", \"details\": { ... }, \"prev_log_hash\": \"<sha256>\", \"log_hash\": \"<sha256>\" }, ... ], \"chain_valid\": true } 6. Prune Tombstone Commitment 6.1 Prune Custody Entry (Enhanced) When pruning, the custody log entry MUST include: { \"action\": \"PRUNE\", \"details\": { \"deleted_range\": { \"ns\": \"<namespace_id>\", \"start\": <unix_ts>, \"end\": <unix_ts>, \"count\": <uint> }, \"deleted_events_hash\": \"<sha256>\", ; hash of deleted data \"sealed_leaf_hash\": \"<sha256>\", ; RTSL leaf that sealed this window \"sth_hash\": \"<sha256>\", ; STH at time of seal \"tombstone_hash\": \"<sha256>\" ; hash of deleted_range CBOR } } 6.2 Tombstone Hash Computation tombstone_cbor = canonical_cbor({ \"ns\": namespace_id, \"start\": start_ts, \"end\": end_ts, \"count\": events_count, \"deleted_events_hash\": deleted_hash }) tombstone_hash = SHA-256(tombstone_cbor) This makes deletion itself auditable evidence . 7. CLI Verification UX 7.1 ritma verify-proofpack <dir> Steps : 1. Load window_page.cbor and window_page.sig.cose 2. Verify COSE_Sign1 signature using keyring/signer_pub.cosekey 3. Recompute hashes of all included payloads 4. Compare against manifest.cbor hashes 5. Verify window_page hash matches rtsl_receipt.cbor leaf 6. Verify inclusion proof against STH root 7. Verify custody_log hash chain Output : Ritma Proofpack Verification ============================ Page signature: \u2705 valid (ES256, signer: demo-node) Manifest hashes: \u2705 5/5 artifacts verified RTSL inclusion: \u2705 leaf #42 in tree of 1000 Custody chain: \u2705 3 entries, chain intact Overall: \u2705 VALID Exit codes : - 0 : Valid - 1 : Tampered (signature or hash mismatch) - 2 : Incomplete (missing files, hash-only mode) - 3 : Error (IO, parse failure) 8. Environment Variables (Policy Knobs) Variable Default Description RITMA_OUT_ENABLE 0 Enable RTSL output RITMA_OUT_FORMAT rtsl Output format: legacy , rtsl , dual RITMA_OUT_ENFORCE_RTSL 0 Hard-fail if RTSL write fails RITMA_PRUNE_REQUIRE_SEAL 1 Prune only sealed windows RITMA_PRUNE_REQUIRE_EXPORT 0 Prune only exported windows RITMA_PRUNE_MIN_AGE_SECS 86400 Minimum age before prune (24h) RITMA_EXPORT_MODE full Export mode: full , hash_only , hybrid RITMA_CAS_ENABLE 1 Enable content-addressed store RITMA_TSA_URL (none) RFC 3161 TSA endpoint RITMA_SIGN_ALG ES256 Signing algorithm: ES256 , EdDSA 9. Implementation Checklist Phase 1: Core (Correctness) [x] window_page.cbor canonical structure in common_models (WindowPageV2, RtslLeafPayloadV2) [x] COSE_Sign1 signing ( ritma_contract/src/cose.rs , window_page.sig.cose ) [x] RTSL leaf = page_hash ( write_window_v2_as_rtsl_record in rtsl.rs) [x] Snapshotter wired to CAS ( serialize_and_store helper in snapshotter) Phase 2: Export (Usability) [x] ritma export-window --ns --start --end command (cmd_export_window) [x] Proofpack directory with exact layout [x] manifest.cbor generation (ManifestV2) [x] rtsl_receipt.cbor with inclusion proof (generate_rtsl_receipt) Phase 3: Verification (Trust) [x] ritma verify-proofpack command (cmd_verify_proofpack) [x] Ed25519 signature verification (verify_page_signature) [x] Hash verification against manifest [x] Inclusion proof verification (verify_rtsl_inclusion_proof) Phase 4: Hardening [x] Custody log v2 (session_id, tool, CBOR details) in index_db [x] Prune tombstone commitment (prune_sealed_window) [x] Prune guardrails (RITMA_PRUNE_REQUIRE_EXPORT, RITMA_PRUNE_MIN_AGE_SECS) [x] CAS wired to snapshotter (store_to_cas, serialize_and_store helpers) [x] RFC 3161 TSA integration ( ritma_contract/src/tsa.rs , RITMA_TSA_URL ) 10. Compatibility Notes RTSL v1 (legacy): Leaf was raw event hashes. Deprecated . RTSL v2 (this spec): Leaf is page_hash . Current . Proofpack v1 : Ad-hoc structure. Deprecated . Proofpack v2 (this spec): Exact layout. Current . Migration: v1 data remains readable but new seals MUST use v2.","title":"Forensics Standard"},{"location":"ritma_transparency_forensics/#ritma-transparency-log-forensics-oneminute-page-industry-standard-design","text":"","title":"Ritma Transparency Log + Forensics \u201cOne\u2011Minute Page\u201d (Industry-Standard Design)"},{"location":"ritma_transparency_forensics/#status","text":"Draft.","title":"Status"},{"location":"ritma_transparency_forensics/#goal","text":"Define an industry-standard , tamper-evident , operator-friendly architecture for Ritma such that for each namespace and each 60s window you can produce a single forensic \u201cpage\u201d that: Reflects exactly what the sensor recorded (the window\u2019s TraceEvent s) Includes BAR outputs (features, graph, ML, verdict, snapshot manifest) Is sealed into an append-only transparency ledger (RTSL) Can be exported into a portable proofpack (human-usable forensic bundle) Supports retention/pruning of hot storage without losing auditability","title":"Goal"},{"location":"ritma_transparency_forensics/#scope","text":"Linux runtime capture ( tracer_sidecar ) Storage ( index_db.sqlite ) as hot/cold path Window processing and sealing ( bar_orchestrator + ritma_contract ) Ledger format ( RTSL ) Export + verification UX ( ritma_cli ) Not covered here: multi-tenant SaaS control plane, remote transparency gossip network, legal admissibility procedures beyond technical chain-of-custody.","title":"Scope"},{"location":"ritma_transparency_forensics/#industry-standards-to-emulate-short-list","text":"","title":"Industry standards to emulate (short list)"},{"location":"ritma_transparency_forensics/#1-certificate-transparency-ct-append-only-merkle-logs-signed-tree-heads","text":"CT defines a Merkle tree with domain separation for leaf vs node hashing, and uses Signed Tree Heads (STHs) and consistency proofs to detect equivocation. Merkle tree + domain separation (leaf uses HASH(0x00 || leaf) ; node uses HASH(0x01 || left || right) ) \u2014 RFC 9162 \u00a72.1.1 https://www.rfc-editor.org/rfc/rfc9162.html Signed Tree Head (STH) (tree_size, root_hash, timestamp, signature) + consistency proof structure \u2014 RFC 9162 \u00a74.9\u20134.11 Why it matters for Ritma: - RTSL is effectively a local transparency log for window commitments. - \u201cHour roots / chain roots\u201d are analogous to CT tree heads.","title":"1) Certificate Transparency (CT): append-only Merkle logs + signed tree heads"},{"location":"ritma_transparency_forensics/#2-trillian-leaf-hashing-vs-identity-hash-store-big-blobs-outside-the-log","text":"Trillian guidance separates: - Merkle hash : what is committed into the transparency log - Identity hash : optional dedupe semantics It also recommends storing large/private blobs outside the transparency log and logging only hashes. Leaf hashing and separate identity hash \u2014 Trillian \u201cTransparent Logging: A Guide\u201d https://raw.githubusercontent.com/google/trillian/master/docs/TransparentLogging.md Why it matters for Ritma: - Don\u2019t stuff raw TraceEvent s inside RTSL; store them in a content-addressed evidence store (or DB) and commit only canonical hashes.","title":"2) Trillian: leaf hashing vs identity hash + store big blobs outside the log"},{"location":"ritma_transparency_forensics/#3-sigstore-rekor-operational-transparency-log-size-limits-sharding","text":"Rekor is a transparency log for signed metadata and highlights operational constraints (e.g., entry size limits, sharding). Rekor v1 public instance + API endpoints + size limits \u2014 Rekor README https://raw.githubusercontent.com/sigstore/rekor/main/README.md Why it matters for Ritma: - Proofpacks / \u201cpages\u201d must remain reasonably sized; large artifacts should be referenced by hash.","title":"3) Sigstore Rekor: operational transparency log + size limits + sharding"},{"location":"ritma_transparency_forensics/#4-cbor-deterministic-encoding","text":"Deterministic encodings are a standard technique to ensure canonical hashes are stable across implementations. Deterministic CBOR encoding requirements \u2014 RFC 8949 \u00a74.2 https://www.rfc-editor.org/rfc/rfc8949.html Why it matters for Ritma: - canonical_leaf_hash() must be based on deterministic encoding. - Proofpacks should use canonical encoding to keep hashes stable.","title":"4) CBOR deterministic encoding"},{"location":"ritma_transparency_forensics/#5-cose-signing","text":"COSE provides standard signed container formats for CBOR payloads. COSE signing structures \u2014 RFC 9052 \u00a74 https://www.rfc-editor.org/rfc/rfc9052.html Why it matters for Ritma: - RTSL signatures and proofpack signatures should follow consistent signing semantics.","title":"5) COSE signing"},{"location":"ritma_transparency_forensics/#6-scitt-signed-statements-receipts-transparency-service-model","text":"SCITT defines a general model for signed statements registered with a transparency service, producing receipts that can be audited. SCITT architecture overview \u2014 draft-ietf-scitt-architecture \u00a75 https://datatracker.ietf.org/doc/html/draft-ietf-scitt-architecture Why it matters for Ritma: - A \u201cone-minute page\u201d can be treated as a signed statement (about a window) with a receipt (RTSL inclusion/consistency material).","title":"6) SCITT: signed statements + receipts + transparency service model"},{"location":"ritma_transparency_forensics/#7-nist-chain-of-custody-definition","text":"For forensic credibility, maintain chain-of-custody metadata. NIST definition (CSRC glossary) https://csrc.nist.gov/glossary/term/chain_of_custody Why it matters for Ritma: - Proofpacks should include who/what produced the page, when, and under what configuration.","title":"7) NIST chain-of-custody definition"},{"location":"ritma_transparency_forensics/#ritma-design-principles-derived-from-standards","text":"","title":"Ritma design principles (derived from standards)"},{"location":"ritma_transparency_forensics/#a-transparency-log-stores-commitments-not-full-data","text":"RTSL should store: time window boundaries tree_size / counts Merkle root of canonical leaf hashes linkage to previous heads (hour root / chain root) signatures","title":"A) Transparency log stores commitments, not full data"},{"location":"ritma_transparency_forensics/#b-evidenceartifacts-are-content-addressed-and-referenced-by-hash","text":"Keep large/private artifacts in: RITMA_OUT/cases/<case_id>/... (or another CAS) or a DB/object store RTSL commits hashes.","title":"B) Evidence/artifacts are content-addressed and referenced by hash"},{"location":"ritma_transparency_forensics/#c-deterministic-canonicalization-everywhere","text":"Leaf hash canonical tuple (already in bar_orchestrator::canonical_leaf_hash ) Canonical CBOR for proofpack files","title":"C) Deterministic canonicalization everywhere"},{"location":"ritma_transparency_forensics/#d-simple-responder-ux","text":"A responder should be able to do: Seal continuously Export one window (by time range) into a \u201cpage/proofpack\u201d directory Verify proofpack against RTSL (and optionally against remote witness)","title":"D) Simple responder UX"},{"location":"ritma_transparency_forensics/#target-oneminute-page-model","text":"","title":"Target \u201cOne\u2011Minute Page\u201d model"},{"location":"ritma_transparency_forensics/#what-the-page-contains","text":"For a window [start,end] and namespace ns : Trace excerpt (sensor truth) list of TraceEvent s in the window possibly redacted (hash-only mode) BAR derived outputs window features summary attack graph edges + graph hash ML score + explanation verdict + reasons Evidence pack manifest list of artifact blobs with sha256 (or stronger hash) privacy redactions Ledger receipt RTSL record reference (segment id / hour root / chain root) signatures (future) inclusion/consistency proofs Chain-of-custody metadata node_id, sensor version, config hash, signer id","title":"What the page contains"},{"location":"ritma_transparency_forensics/#where-each-part-lives","text":"Hot path : index_db.sqlite (queryable, pruneable) Transparency ledger : RTSL ( RITMA_OUT/ledger/v2/... ) commits roots Evidence store : proofpack/case directory containing files, referenced by hash This mirrors Trillian guidance: log the hash; store large data separately.","title":"Where each part lives"},{"location":"ritma_transparency_forensics/#mapping-to-current-ritma-code","text":"","title":"Mapping to current Ritma code"},{"location":"ritma_transparency_forensics/#capture","text":"crates/tracer_sidecar produces common_models::TraceEvent Inserts into IndexDb::insert_trace_event_from_model()","title":"Capture"},{"location":"ritma_transparency_forensics/#window-processing-sealing","text":"crates/bar_orchestrator::Orchestrator::run_window() Correlate window (features + attack graph) Run ML Judge Snapshot (optional) Seal (proof metadata + receipts) Write RITMA_OUT via StorageContract::write_window_output()","title":"Window processing + sealing"},{"location":"ritma_transparency_forensics/#ledger-output-format","text":"crates/ritma_contract::StorageContract::write_window_output() RITMA_OUT_FORMAT=legacy|rtsl|dual RITMA_OUT_ENFORCE_RTSL=1 forces RTSL","title":"Ledger output format"},{"location":"ritma_transparency_forensics/#proofpack-export","text":"crates/ritma_cli has export functions that read IndexDB (events/features/ml/etc.) and write canonical CBOR files.","title":"Proofpack export"},{"location":"ritma_transparency_forensics/#known-gaps-what-must-change","text":"","title":"Known gaps (what must change)"},{"location":"ritma_transparency_forensics/#1-snapshot-must-include-the-real-trace-excerpt","text":"Bug fixed : bar_orchestrator previously called snapshotter with &[] . It must pass the actual trace_events excerpt for [start,end] .","title":"1) Snapshot must include the real trace excerpt"},{"location":"ritma_transparency_forensics/#2-snapshotter-returns-only-hashesmetadata-not-persisted-artifacts","text":"Today snapshotter computes artifact hashes but does not write the artifact payloads into an evidence store. Industry standard practice is: - write artifacts to a content-addressed store - log the hashes + metadata in the manifest","title":"2) Snapshotter returns only hashes/metadata, not persisted artifacts"},{"location":"ritma_transparency_forensics/#3-export-should-not-require-ml-id","text":"UX should allow: - ritma export-window --namespace ... --start ... --end ... producing one proofpack","title":"3) Export should not require ML id"},{"location":"ritma_transparency_forensics/#4-rtsl-only-should-be-the-default-for-production","text":"If RTSL is the standard, deployments should enforce it (and optionally disallow legacy output).","title":"4) RTSL-only should be the default for production"},{"location":"ritma_transparency_forensics/#5-retention-should-be-explicit-and-safe","text":"Pruning trace_events must happen only after: - RTSL record exists - proofpack/evidence is exported or copied to long-term storage","title":"5) Retention should be explicit and safe"},{"location":"ritma_transparency_forensics/#recommended-implementation-plan-in-repo","text":"","title":"Recommended implementation plan (in repo)"},{"location":"ritma_transparency_forensics/#phase-1-correctness","text":"Ensure bar_orchestrator passes real per-window trace_excerpt to snapshotter. Enforce RTSL-only in production configurations.","title":"Phase 1 (correctness)"},{"location":"ritma_transparency_forensics/#phase-2-forensic-usability","text":"Add a window export command that generates the \u201cone-minute page\u201d proofpack directly from (namespace,start,end) . Include the trace excerpt file in the proofpack (canonical CBOR).","title":"Phase 2 (forensic usability)"},{"location":"ritma_transparency_forensics/#phase-3-evidence-store","text":"Implement snapshot artifact persistence to an evidence store (e.g., RITMA_OUT/cases/<case_id>/... ). Proofpack references should be hash-addressed.","title":"Phase 3 (evidence store)"},{"location":"ritma_transparency_forensics/#phase-4-transparency-hardening","text":"Add verifiable inclusion/consistency proof material for RTSL (CT-like proofs). Add witness/gossip support (future).","title":"Phase 4 (transparency hardening)"},{"location":"ritma_transparency_forensics/#environment-recommendations","text":"For production-grade \u201cRTSL standard\u201d deployments: RITMA_OUT_ENABLE=1 RITMA_OUT_FORMAT=rtsl RITMA_OUT_ENFORCE_RTSL=1","title":"Environment recommendations"},{"location":"ritma_transparency_forensics/#success-criteria","text":"Given a window [start,end] , exported proofpack contains: trace_events.cbor (what sidecar recorded) attack_graph.cbor , coverage.cbor , ml_score , verdict manifest.cbor Verification confirms: proofpack hashes match IndexDB records merkle root matches RTSL record for that window","title":"Success criteria"},{"location":"ritma_transparency_forensics/#chain-of-custody-coc-industry-standard-requirements","text":"This section defines Ritma's chain-of-custody architecture for military , critical infrastructure , financial , and court-admissible forensic contexts. It draws from: ACPO/NPCC Good Practice Guide (UK digital evidence principles) ISO/IEC 27037:2012 \u2014 identification, collection, acquisition, preservation of digital evidence ISO/IEC 27041:2015 \u2014 assuring suitability of investigative methods ISO/IEC 27042:2015 \u2014 analysis and interpretation of digital evidence ISO/IEC 27043:2015 \u2014 incident investigation principles and processes NIST SP 800-86 \u2014 integrating forensic techniques into incident response NISTIR 8387 \u2014 digital evidence preservation for evidence handlers NIST SP 800-88 Rev.1 \u2014 media sanitization (secure deletion) RFC 3161 \u2014 Time-Stamp Protocol (TSP) for evidence timestamping IETF COSE Merkle Tree Proofs (draft-ietf-cose-merkle-tree-proofs) \u2014 receipts for transparency logs","title":"Chain-of-Custody (CoC) \u2014 Industry-Standard Requirements"},{"location":"ritma_transparency_forensics/#coc-principle-1-no-action-should-change-evidence","text":"Standard : ACPO Principle 1 / ISO 27037 \u00a77.1.1 Ritma implementation : - tracer_sidecar captures events in append-only mode; no modification of raw events after insertion. - index_db uses hash chaining ( event_hash , prev_hash ) so any tampering breaks the chain. - RTSL commits Merkle roots of sealed windows; once sealed, the window's hash is immutable.","title":"CoC Principle 1: No action should change evidence"},{"location":"ritma_transparency_forensics/#coc-principle-2-competent-persons-access-evidence-with-audit-trail","text":"Standard : ACPO Principle 2 / ISO 27037 \u00a77.1.2 / UK MoJ POL.POP.009\u2013011 Ritma implementation : - Every custody-relevant action is logged to a custody_log table: - CAPTURE \u2014 sidecar inserted events - SEAL \u2014 bar_orchestrator sealed window into RTSL - EXPORT \u2014 proofpack exported - PRUNE \u2014 hot data deleted after seal - VERIFY \u2014 proofpack verified - Each log entry includes: - timestamp (RFC 3339, ideally RFC 3161 TSA-signed) - actor_id (node_id / user / service principal) - action - target (namespace, window_id, artifact hash) - prev_log_hash (hash chain for tamper detection) - signature (optional, for high-assurance deployments)","title":"CoC Principle 2: Competent persons access evidence with audit trail"},{"location":"ritma_transparency_forensics/#coc-principle-3-audit-trail-enables-third-party-replication","text":"Standard : ACPO Principle 3 / ISO 27043 \u00a76.3 / UK MoJ POL.POP.009 Ritma implementation : - Proofpacks include: - custody_log.cbor \u2014 excerpt of custody events for that window - manifest.cbor \u2014 artifact hashes + metadata - rtsl_receipt.cbor \u2014 RTSL inclusion proof (Merkle path + signed tree head) - A third party can: 1. Verify trace_events.cbor hash matches manifest 2. Verify manifest hash matches RTSL leaf 3. Verify RTSL inclusion proof against signed tree head 4. Verify custody_log hash chain is unbroken","title":"CoC Principle 3: Audit trail enables third-party replication"},{"location":"ritma_transparency_forensics/#coc-principle-4-investigation-leader-ensures-legal-compliance","text":"Standard : ACPO Principle 4 / ISO 27041 / UK MoJ POL.POP.014 Ritma implementation : - Ritma provides technical controls ; legal/procedural compliance is the operator's responsibility. - Configuration options: - RITMA_COC_REQUIRE_SIGNATURE=1 \u2014 require cryptographic signature on custody log entries - RITMA_COC_TSA_URL=... \u2014 RFC 3161 Time-Stamp Authority for external timestamping - RITMA_COC_RETENTION_DAYS=... \u2014 minimum retention before pruning allowed","title":"CoC Principle 4: Investigation leader ensures legal compliance"},{"location":"ritma_transparency_forensics/#secure-deletion-after-sealing-tamper-evident-pruning","text":"","title":"Secure Deletion After Sealing \u2014 Tamper-Evident Pruning"},{"location":"ritma_transparency_forensics/#problem","text":"Storing all raw TraceEvent s indefinitely is impractical for high-volume deployments. However, deleting evidence without proper controls could: 1. Destroy forensic value before it's needed 2. Enable cover-ups by malicious insiders 3. Violate retention regulations (PIPEDA 2yr, Qu\u00e9bec Law 25 5yr, etc.)","title":"Problem"},{"location":"ritma_transparency_forensics/#industry-guidance","text":"NIST SP 800-88 Rev.1 : Sanitization must be verified and documented . Cryptographic erasure (deleting keys) is acceptable if keys are irreversibly destroyed. ISO 27037 \u00a77.4 : Preservation includes documenting any changes to evidence, including destruction. UK MoJ POL.POP.013 : Forensic Readiness Plan must include secure disposal procedures.","title":"Industry guidance"},{"location":"ritma_transparency_forensics/#ritma-secure-deletion-policy","text":"Rule : Raw data in index_db may be pruned only after : 1. The window is sealed into RTSL (Merkle root committed) 2. A custody_log entry of type PRUNE is recorded with: - window boundaries - count of events deleted - hash of deleted data (for audit) - reference to RTSL seal record 3. (Optional) Proofpack has been exported to long-term storage Implementation : index_db.prune_sealed_window(namespace, window_id) -> PruneResult 1. Verify window_id exists in RTSL (sealed) 2. Compute hash of events to be deleted 3. Insert custody_log entry (action=PRUNE, target=window_id, data_hash=...) 4. DELETE FROM trace_events WHERE namespace=? AND ts >= start AND ts <= end 5. Return PruneResult { events_deleted, custody_log_id } Guardrails : - RITMA_PRUNE_REQUIRE_SEAL=1 (default) \u2014 prune fails if window not sealed - RITMA_PRUNE_REQUIRE_EXPORT=1 \u2014 prune fails if proofpack not exported - RITMA_PRUNE_MIN_AGE_HOURS=24 \u2014 minimum age before pruning allowed","title":"Ritma secure deletion policy"},{"location":"ritma_transparency_forensics/#exploitation-prevention","text":"Attack vector Mitigation Attacker deletes events before seal prune_sealed_window checks RTSL seal exists; fails otherwise Attacker modifies custody_log custody_log uses hash chaining; any gap/modification detectable Attacker replays old seal to justify deletion RTSL seal includes timestamp; prune checks seal_ts < prune_ts Attacker with DB access deletes directly custody_log is append-only; missing entries detectable by hash chain gaps Attacker deletes custody_log custody_log can be replicated to external witness / SIEM; gaps detectable","title":"Exploitation prevention"},{"location":"ritma_transparency_forensics/#cryptographic-erasure-future","text":"For deployments requiring NIST 800-88 \"Purge\" level: - Encrypt trace_events with per-window key - Store key in HSM or secure enclave - Pruning = delete key (cryptographic erasure) - Custody_log records key deletion event","title":"Cryptographic erasure (future)"},{"location":"ritma_transparency_forensics/#custody-log-schema","text":"CREATE TABLE IF NOT EXISTS custody_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT NOT NULL, -- RFC 3339 timestamp actor_id TEXT NOT NULL, -- node_id / user / service action TEXT NOT NULL, -- CAPTURE|SEAL|EXPORT|PRUNE|VERIFY|ACCESS namespace_id TEXT, window_id TEXT, target_hash TEXT, -- hash of affected data details TEXT, -- JSON metadata prev_log_hash TEXT, -- hash chain log_hash TEXT NOT NULL, -- hash of this entry signature TEXT, -- optional cryptographic signature tsa_token BLOB -- optional RFC 3161 timestamp token ); CREATE INDEX IF NOT EXISTS idx_custody_log_ns_ts ON custody_log(namespace_id, ts); CREATE INDEX IF NOT EXISTS idx_custody_log_action ON custody_log(action);","title":"Custody Log Schema"},{"location":"ritma_transparency_forensics/#rfc-3161-timestamping-optional","text":"For court-admissible evidence, external timestamping proves evidence existed at a specific time: Compute hash of sealed window (or custody_log entry) Send TimeStampReq to TSA (e.g., FreeTSA, DigiCert, Entrust) Receive TimeStampResp containing signed timestamp token Store token in custody_log.tsa_token or proofpack Configuration : - RITMA_TSA_URL=https://freetsa.org/tsr (example) - RITMA_TSA_HASH_ALG=SHA-256","title":"RFC 3161 Timestamping (Optional)"},{"location":"ritma_transparency_forensics/#cose-receipts-for-rtsl-future","text":"IETF draft-ietf-cose-merkle-tree-proofs defines CBOR-encoded receipts for transparency logs: Inclusion proof : proves a leaf is in the Merkle tree Consistency proof : proves tree grew append-only Ritma can adopt this format for rtsl_receipt.cbor : { \"vds\": 1, // RFC9162_SHA256 \"tree_size\": 12345, \"root\": h'...', // 32-byte root hash \"leaf_index\": 42, \"inclusion_path\": [h'...', h'...', ...], \"signature\": h'...' // COSE_Sign1 }","title":"COSE Receipts for RTSL (Future)"},{"location":"ritma_transparency_forensics/#summary-ritma-coc-compliance-matrix","text":"Requirement Standard Ritma Feature Append-only evidence capture ISO 27037, ACPO P1 hash-chained trace_events Tamper-evident ledger CT, SCITT RTSL Merkle tree + signed roots Audit trail for all actions ACPO P2-3, ISO 27043 custody_log table Secure deletion with proof NIST 800-88, ISO 27037 prune_sealed_window + custody_log External timestamping RFC 3161 TSA integration (optional) Portable evidence bundle ISO 27042 proofpack export Third-party verification ACPO P3 inclusion proofs + hash verification","title":"Summary: Ritma CoC Compliance Matrix"},{"location":"ritma_transparency_forensics/#-","text":"","title":"---"},{"location":"ritma_transparency_forensics/#ritma-v2-forensic-page-standard-normative-specification","text":"Status : Draft Normative Version : 2.0 Applies to : RTSL, Proofpack, CAS, Custody Log This section defines the exact bytes-on-disk , exact hashes/signatures , and exact file names for Ritma forensic evidence. Implementations MUST NOT deviate from this specification.","title":"Ritma v2 Forensic Page Standard (Normative Specification)"},{"location":"ritma_transparency_forensics/#1-window-page-the-canonical-signed-statement","text":"","title":"1. Window Page: The Canonical Signed Statement"},{"location":"ritma_transparency_forensics/#11-window_pagecbor-the-scitt-like-statement","text":"The window page is the single canonical object that everything else references. It is a signed statement (SCITT-shaped) that commits to all evidence for a one-minute window. Encoding : Deterministic CBOR (RFC 8949 \u00a74.2) Map key ordering : Lexicographic by UTF-8 bytes Integer encoding : Minimal bytes Float encoding : Shortest form preserving value","title":"1.1 window_page.cbor \u2014 The SCITT-like Statement"},{"location":"ritma_transparency_forensics/#111-canonical-cbor-map-structure","text":"{ \"v\": 2, ; page format version (integer) \"ns\": \"<namespace_id>\", ; namespace URI (tstr) \"win\": { ; window boundaries \"id\": \"<window_id>\", ; UUID (tstr) \"start\": \"<RFC3339>\", ; window start (tstr) \"end\": \"<RFC3339>\" ; window end (tstr) }, \"sensor\": { ; sensor identity \"node_id\": \"<RITMA_NODE_ID>\", ; node identifier (tstr) \"tracer_ver\": \"<semver>\", ; tracer_sidecar version (tstr) \"bar_ver\": \"<semver>\" ; bar_orchestrator version (tstr) }, \"cfg\": { ; configuration hashes \"config_hash\": \"<sha256>\", ; effective config hash (tstr) \"policy_hash\": \"<sha256>\" ; policy pack hash (tstr) }, \"counts\": { ; event counts (for quick triage) \"events\": <uint>, ; trace_events count \"edges\": <uint>, ; attack_graph edges count \"artifacts\": <uint> ; evidence artifacts count }, \"trace\": { ; trace evidence commitment \"mode\": \"full\" | \"hash_only\", ; privacy mode (tstr) \"trace_cbor_hash\": \"<sha256>\", ; SHA-256 of trace_events.cbor (tstr) \"trace_chain_head\": \"<sha256>\" ; last event_hash in window (tstr, optional) }, \"bar\": { ; BAR outputs commitment \"features_hash\": \"<sha256>\", ; SHA-256 of features.cbor (tstr) \"graph_hash\": \"<sha256>\", ; SHA-256 of attack_graph.cbor (tstr) \"ml_hash\": \"<sha256>\", ; SHA-256 of ml_result.cbor (tstr) \"verdict_hash\": \"<sha256>\" ; SHA-256 of verdict.cbor (tstr) }, \"manifest_hash\": \"<sha256>\", ; SHA-256 of manifest.cbor (tstr) \"custody_log_hash\": \"<sha256>\", ; SHA-256 of custody_log.cbor (tstr) \"rtsl\": { ; RTSL commitment \"leaf_hash\": \"<sha256>\", ; CT-style leaf hash (tstr) \"leaf_index\": <uint>, ; position in log (uint, optional) \"sth_ref\": \"<sha256>\" ; STH hash reference (tstr) }, \"time\": { ; timestamps \"sealed_ts\": \"<RFC3339>\", ; seal timestamp (tstr) \"tsa_token_hash\": \"<sha256>\" ; RFC 3161 token hash (tstr, optional) } }","title":"1.1.1 Canonical CBOR Map Structure"},{"location":"ritma_transparency_forensics/#112-hash-computation","text":"All hashes in this spec are SHA-256 unless otherwise noted. hash(x) = SHA-256(x) For files: file_hash = SHA-256(file_bytes)","title":"1.1.2 Hash Computation"},{"location":"ritma_transparency_forensics/#12-window_pagesigcose-cose_sign1-signature","text":"The page MUST be signed using COSE_Sign1 (RFC 9052 \u00a74.2). Algorithm : ES256 (ECDSA w/ SHA-256 on P-256) or EdDSA (Ed25519) Protected header : { 1: -7, ; alg: ES256 (or -8 for EdDSA) 3: \"application/ritma-page+cbor\" ; content type } Payload : The exact bytes of window_page.cbor External AAD : Empty COSE_Sign1 = [ protected: << { 1: -7, 3: \"application/ritma-page+cbor\" } >>, unprotected: {}, payload: << window_page.cbor bytes >>, signature: << 64 bytes for ES256 >> ]","title":"1.2 window_page.sig.cose \u2014 COSE_Sign1 Signature"},{"location":"ritma_transparency_forensics/#2-rtsl-leaf-definition-hard-rule","text":"","title":"2. RTSL Leaf Definition (Hard Rule)"},{"location":"ritma_transparency_forensics/#21-leaf-payload","text":"RTSL commits to the page hash , not raw events. The leaf payload is a minimal routing envelope: { \"v\": 2, ; RTSL version \"ns\": \"<namespace_id>\", ; namespace \"win_id\": \"<window_id>\", ; window UUID \"start\": <unix_ts>, ; window start (integer seconds) \"end\": <unix_ts>, ; window end (integer seconds) \"page_hash\": \"<sha256>\" ; SHA-256 of window_page.cbor } Canonical encoding : Deterministic CBOR, keys sorted lexicographically.","title":"2.1 Leaf Payload"},{"location":"ritma_transparency_forensics/#22-leaf-hash-ct-style-domain-separation","text":"leaf_payload_bytes = canonical_cbor(leaf_payload) leaf_hash = SHA-256(0x00 || leaf_payload_bytes) The 0x00 prefix is the leaf domain separator per RFC 9162 \u00a72.1.","title":"2.2 Leaf Hash (CT-style Domain Separation)"},{"location":"ritma_transparency_forensics/#23-node-hash-merkle-tree-interior","text":"node_hash = SHA-256(0x01 || left_hash || right_hash) The 0x01 prefix is the node domain separator .","title":"2.3 Node Hash (Merkle Tree Interior)"},{"location":"ritma_transparency_forensics/#24-signed-tree-head-sth","text":"{ \"v\": 2, ; STH version \"log_id\": \"<sha256>\", ; log identity (hash of log public key) \"tree_size\": <uint>, ; number of leaves \"root_hash\": \"<sha256>\", ; Merkle root \"timestamp\": \"<RFC3339>\", ; STH timestamp \"signature\": \"<base64>\" ; COSE_Sign1 detached signature } The STH MUST be signed with the log's signing key (same algorithm as page signatures).","title":"2.4 Signed Tree Head (STH)"},{"location":"ritma_transparency_forensics/#3-proofpack-directory-layout-exact-boring-predictable","text":"When exporting a window: ritma export-window --ns <ns> --start <RFC3339> --end <RFC3339> Output directory structure: proofpack_<ns_safe>_<start_ts>_<end_ts>/ \u251c\u2500\u2500 README.txt # Human one-screen summary \u251c\u2500\u2500 window_page.cbor # The canonical signed statement \u251c\u2500\u2500 window_page.sig.cose # COSE_Sign1 signature \u2502 \u251c\u2500\u2500 trace_events.cbor # Optional (omit if hash_only mode) \u251c\u2500\u2500 attack_graph.cbor # Attack graph edges \u251c\u2500\u2500 features.cbor # Window features \u251c\u2500\u2500 ml_result.cbor # ML score + explanation \u251c\u2500\u2500 verdict.cbor # Verdict + reasons \u2502 \u251c\u2500\u2500 manifest.cbor # Artifact manifest with hashes \u251c\u2500\u2500 custody_log.cbor # Custody log excerpt for this window \u2502 \u251c\u2500\u2500 rtsl_receipt.cbor # STH + inclusion proof \u251c\u2500\u2500 keyring/ \u2502 \u2514\u2500\u2500 signer_pub.cosekey # Public key for signature verification \u2502 \u2514\u2500\u2500 hashes.txt # Human-friendly digest list (optional)","title":"3. Proofpack Directory Layout (Exact, Boring, Predictable)"},{"location":"ritma_transparency_forensics/#31-file-naming-convention","text":"<ns_safe> : namespace with / replaced by _ , max 64 chars <start_ts> , <end_ts> : Unix timestamp (integer seconds) Example: proofpack_ns___test_prod_app_svc_1737331200_1737331260/","title":"3.1 File Naming Convention"},{"location":"ritma_transparency_forensics/#32-readmetxt-format","text":"Ritma Forensic Proofpack v2 =========================== Namespace: ns://test/prod/app/svc Window: 2025-01-19T12:00:00Z to 2025-01-19T12:01:00Z Window ID: a1b2c3d4-e5f6-7890-abcd-ef1234567890 Node: demo-node Sealed: 2025-01-19T12:01:05Z Counts: Events: 142 Edges: 23 Artifacts: 5 Verification: ritma verify-proofpack . Page Hash: sha256:abc123... RTSL Leaf: #42 in log STH Root: sha256:def456...","title":"3.2 README.txt Format"},{"location":"ritma_transparency_forensics/#33-manifestcbor-structure","text":"{ \"v\": 2, \"artifacts\": [ { \"name\": \"trace_events.cbor\", \"sha256\": \"<hash>\", \"size\": <bytes>, \"cas_ref\": \"sha256/<aa>/<bb>/<hash>\" ; optional CAS path }, ... ], \"privacy\": { \"mode\": \"full\" | \"hash_only\", \"redactions\": [\"pii\", \"secrets\"] } }","title":"3.3 manifest.cbor Structure"},{"location":"ritma_transparency_forensics/#34-rtsl_receiptcbor-structure","text":"{ \"v\": 2, \"leaf_index\": <uint>, \"leaf_hash\": \"<sha256>\", \"inclusion_path\": [ { \"side\": \"L\" | \"R\", \"hash\": \"<sha256>\" }, ... ], \"sth\": { \"tree_size\": <uint>, \"root_hash\": \"<sha256>\", \"timestamp\": \"<RFC3339>\", \"log_id\": \"<sha256>\", \"signature\": \"<base64>\" } }","title":"3.4 rtsl_receipt.cbor Structure"},{"location":"ritma_transparency_forensics/#4-content-addressed-store-cas","text":"","title":"4. Content-Addressed Store (CAS)"},{"location":"ritma_transparency_forensics/#41-filesystem-cas-layout","text":"RITMA_OUT/cas/sha256/<aa>/<bb>/<full_hash> Where: - <aa> = first 2 hex chars of hash - <bb> = next 2 hex chars - <full_hash> = full 64-char hex SHA-256 Example: RITMA_OUT/cas/sha256/ab/cd/abcd1234567890...","title":"4.1 Filesystem CAS Layout"},{"location":"ritma_transparency_forensics/#42-cas-operations","text":"Store : fn cas_store(data: &[u8]) -> String { let hash = sha256(data); let path = format!(\"cas/sha256/{}/{}/{}\", &hash[0..2], &hash[2..4], hash); write_if_not_exists(path, data); hash } Retrieve : fn cas_get(hash: &str) -> Option<Vec<u8>> { let path = format!(\"cas/sha256/{}/{}/{}\", &hash[0..2], &hash[2..4], hash); read_file(path).ok() }","title":"4.2 CAS Operations"},{"location":"ritma_transparency_forensics/#43-proofpack-export-modes","text":"Mode Behavior full Include all artifact payloads in proofpack hash_only Include only hashes; payloads stay in CAS hybrid Include small artifacts (<1MB); hash large ones","title":"4.3 Proofpack Export Modes"},{"location":"ritma_transparency_forensics/#5-custody-log-v2-courtaudit-friendly","text":"","title":"5. Custody Log v2 (Court/Audit Friendly)"},{"location":"ritma_transparency_forensics/#51-enhanced-schema","text":"CREATE TABLE IF NOT EXISTS custody_log ( id INTEGER PRIMARY KEY AUTOINCREMENT, ts TEXT NOT NULL, -- RFC 3339 timestamp actor_id TEXT NOT NULL, -- node_id / user / service session_id TEXT, -- ties actions within process lifetime tool TEXT NOT NULL, -- tracer_sidecar | bar_orchestrator | ritma_cli action TEXT NOT NULL, -- CAPTURE|SEAL|EXPORT|PRUNE|VERIFY|ACCESS namespace_id TEXT, window_id TEXT, target_hash TEXT, -- hash of affected data details BLOB, -- CBOR (not JSON) for canonicalization prev_log_hash TEXT, -- hash chain log_hash TEXT NOT NULL, -- hash of this entry signature TEXT, -- optional cryptographic signature tsa_token BLOB, -- optional RFC 3161 timestamp token host_attestation TEXT -- optional TPM/IMA hash );","title":"5.1 Enhanced Schema"},{"location":"ritma_transparency_forensics/#52-custody-log-entry-hash","text":"entry_bytes = canonical_cbor({ ts, actor_id, session_id, tool, action, namespace_id, window_id, target_hash, details_hash, prev_log_hash }) log_hash = SHA-256(entry_bytes)","title":"5.2 Custody Log Entry Hash"},{"location":"ritma_transparency_forensics/#53-custody_logcbor-export-format","text":"{ \"v\": 2, \"entries\": [ { \"ts\": \"<RFC3339>\", \"actor_id\": \"<id>\", \"session_id\": \"<uuid>\", \"tool\": \"bar_orchestrator\", \"action\": \"SEAL\", \"namespace_id\": \"<ns>\", \"window_id\": \"<win_id>\", \"target_hash\": \"<sha256>\", \"details\": { ... }, \"prev_log_hash\": \"<sha256>\", \"log_hash\": \"<sha256>\" }, ... ], \"chain_valid\": true }","title":"5.3 custody_log.cbor Export Format"},{"location":"ritma_transparency_forensics/#6-prune-tombstone-commitment","text":"","title":"6. Prune Tombstone Commitment"},{"location":"ritma_transparency_forensics/#61-prune-custody-entry-enhanced","text":"When pruning, the custody log entry MUST include: { \"action\": \"PRUNE\", \"details\": { \"deleted_range\": { \"ns\": \"<namespace_id>\", \"start\": <unix_ts>, \"end\": <unix_ts>, \"count\": <uint> }, \"deleted_events_hash\": \"<sha256>\", ; hash of deleted data \"sealed_leaf_hash\": \"<sha256>\", ; RTSL leaf that sealed this window \"sth_hash\": \"<sha256>\", ; STH at time of seal \"tombstone_hash\": \"<sha256>\" ; hash of deleted_range CBOR } }","title":"6.1 Prune Custody Entry (Enhanced)"},{"location":"ritma_transparency_forensics/#62-tombstone-hash-computation","text":"tombstone_cbor = canonical_cbor({ \"ns\": namespace_id, \"start\": start_ts, \"end\": end_ts, \"count\": events_count, \"deleted_events_hash\": deleted_hash }) tombstone_hash = SHA-256(tombstone_cbor) This makes deletion itself auditable evidence .","title":"6.2 Tombstone Hash Computation"},{"location":"ritma_transparency_forensics/#7-cli-verification-ux","text":"","title":"7. CLI Verification UX"},{"location":"ritma_transparency_forensics/#71-ritma-verify-proofpack-dir","text":"Steps : 1. Load window_page.cbor and window_page.sig.cose 2. Verify COSE_Sign1 signature using keyring/signer_pub.cosekey 3. Recompute hashes of all included payloads 4. Compare against manifest.cbor hashes 5. Verify window_page hash matches rtsl_receipt.cbor leaf 6. Verify inclusion proof against STH root 7. Verify custody_log hash chain Output : Ritma Proofpack Verification ============================ Page signature: \u2705 valid (ES256, signer: demo-node) Manifest hashes: \u2705 5/5 artifacts verified RTSL inclusion: \u2705 leaf #42 in tree of 1000 Custody chain: \u2705 3 entries, chain intact Overall: \u2705 VALID Exit codes : - 0 : Valid - 1 : Tampered (signature or hash mismatch) - 2 : Incomplete (missing files, hash-only mode) - 3 : Error (IO, parse failure)","title":"7.1 ritma verify-proofpack &lt;dir&gt;"},{"location":"ritma_transparency_forensics/#8-environment-variables-policy-knobs","text":"Variable Default Description RITMA_OUT_ENABLE 0 Enable RTSL output RITMA_OUT_FORMAT rtsl Output format: legacy , rtsl , dual RITMA_OUT_ENFORCE_RTSL 0 Hard-fail if RTSL write fails RITMA_PRUNE_REQUIRE_SEAL 1 Prune only sealed windows RITMA_PRUNE_REQUIRE_EXPORT 0 Prune only exported windows RITMA_PRUNE_MIN_AGE_SECS 86400 Minimum age before prune (24h) RITMA_EXPORT_MODE full Export mode: full , hash_only , hybrid RITMA_CAS_ENABLE 1 Enable content-addressed store RITMA_TSA_URL (none) RFC 3161 TSA endpoint RITMA_SIGN_ALG ES256 Signing algorithm: ES256 , EdDSA","title":"8. Environment Variables (Policy Knobs)"},{"location":"ritma_transparency_forensics/#9-implementation-checklist","text":"","title":"9. Implementation Checklist"},{"location":"ritma_transparency_forensics/#phase-1-core-correctness","text":"[x] window_page.cbor canonical structure in common_models (WindowPageV2, RtslLeafPayloadV2) [x] COSE_Sign1 signing ( ritma_contract/src/cose.rs , window_page.sig.cose ) [x] RTSL leaf = page_hash ( write_window_v2_as_rtsl_record in rtsl.rs) [x] Snapshotter wired to CAS ( serialize_and_store helper in snapshotter)","title":"Phase 1: Core (Correctness)"},{"location":"ritma_transparency_forensics/#phase-2-export-usability","text":"[x] ritma export-window --ns --start --end command (cmd_export_window) [x] Proofpack directory with exact layout [x] manifest.cbor generation (ManifestV2) [x] rtsl_receipt.cbor with inclusion proof (generate_rtsl_receipt)","title":"Phase 2: Export (Usability)"},{"location":"ritma_transparency_forensics/#phase-3-verification-trust","text":"[x] ritma verify-proofpack command (cmd_verify_proofpack) [x] Ed25519 signature verification (verify_page_signature) [x] Hash verification against manifest [x] Inclusion proof verification (verify_rtsl_inclusion_proof)","title":"Phase 3: Verification (Trust)"},{"location":"ritma_transparency_forensics/#phase-4-hardening","text":"[x] Custody log v2 (session_id, tool, CBOR details) in index_db [x] Prune tombstone commitment (prune_sealed_window) [x] Prune guardrails (RITMA_PRUNE_REQUIRE_EXPORT, RITMA_PRUNE_MIN_AGE_SECS) [x] CAS wired to snapshotter (store_to_cas, serialize_and_store helpers) [x] RFC 3161 TSA integration ( ritma_contract/src/tsa.rs , RITMA_TSA_URL )","title":"Phase 4: Hardening"},{"location":"ritma_transparency_forensics/#10-compatibility-notes","text":"RTSL v1 (legacy): Leaf was raw event hashes. Deprecated . RTSL v2 (this spec): Leaf is page_hash . Current . Proofpack v1 : Ad-hoc structure. Deprecated . Proofpack v2 (this spec): Exact layout. Current . Migration: v1 data remains readable but new seals MUST use v2.","title":"10. Compatibility Notes"}]}